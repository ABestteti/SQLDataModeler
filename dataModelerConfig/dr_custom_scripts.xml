<?xml version="1.0" encoding="UTF-8" ?>
<dr_custom_scripts>
	<scr id="9836D087-881D-2161-19AF-2C6DF49A964A" name="Before Create" object="null" engine="Oracle Nashorn" type="" var="model" library="" method="" purpose="ddl_transformation" >
		<script>
			<![CDATA[]]>
		</script>
	</scr>
	<scr id="B50F3C56-0DC4-6376-8CF9-9CB189DC97DD" name="After Create" object="null" engine="Oracle Nashorn" type="" var="model" library="" method="" purpose="ddl_transformation" >
		<script>
			<![CDATA[/*
variable ddlStatementsList should be used to return the list with DDL statements
that are created by script - as shown below:
ddlStatementsList.add(new java.lang.String(ddl));
other available variables:
- model - relational model instance
- pModel - physical model instance
- table - the table in relational model
- tableProxy - table definition in physical model
*/
var ddl;
var lname;
//journal table name suffix
jnTabSuf = "_JN";
// trigger name suffix
jnTrgSuf = "_JNtrg";
prompt = model.getAppView().getSettings().isIncludePromptInDDL();
useSchema = model.getAppView().getSettings().isIncludeSchemaInDDL();
if(model.getStorageDesign().isOpen()){
	if(useSchema){
	     lname = tableProxy.getLongName();
	}else{
		lname = tableProxy.getName();
	}
}else{
	if(useSchema){
	     lname = table.getLongName();
	}else{
		lname = table.getName();
	}
}
if(prompt){
	ddl= "PROMPT Creating Journal Table for '"+lname+"';\n";
}else{
	ddl = "";
}
ddl = ddl + "CREATE TABLE "+lname+jnTabSuf+"\n"+
" (JN_OPERATION CHAR(3) NOT NULL"+"\n"+
" ,JN_ORACLE_USER VARCHAR2(30) NOT NULL"+"\n"+
" ,JN_DATETIME DATE NOT NULL"+"\n"+
" ,JN_NOTES VARCHAR2(240)"+"\n"+
" ,JN_APPLN VARCHAR2(35)"+"\n"+
" ,JN_SESSION NUMBER(38)"+"\n";
cols = table.getElements();
for(var i=0;i<cols.length;i++){
	col = cols[i];
	ddl = ddl +" ,"+col.getName()+" "+col.getDatatypeString();
	if(col.isMandatory()){
		ddl = ddl + " NOT NULL\n";
	}else{
		ddl = ddl + "\n";
	}
}
ddl = ddl + " );";
ddlStatementsList.add(new java.lang.String(ddl));
if(prompt){
	ddl= "\nPROMPT Creating Journal Trigger for '"+lname+"';\n";
}else{
	ddl = "\n";
}
ddl = ddl +
"CREATE OR REPLACE TRIGGER "+lname+jnTrgSuf +"\n"+
"  AFTER \n" +
"  INSERT OR \n" +
"  UPDATE OR \n" +
"  DELETE ON "+lname+" for each row \n" +
" Declare \n" +
"  rec "+lname+"_JN"+"%ROWTYPE; \n" +
"  blank "+lname+"_JN"+"%ROWTYPE; \n" +
"  BEGIN \n" +
"    rec := blank; \n" +
"    IF INSERTING OR UPDATING THEN \n" ;
for(var i=0;i<cols.length;i++){
	col = cols[i];
	ddl = ddl + "      rec."+col.getName()+" := :NEW."+col.getName()+"; \n";
}
ddl = ddl +
"      rec.JN_DATETIME := SYSDATE; \n" +
"      rec.JN_ORACLE_USER := SYS_CONTEXT ('USERENV', 'SESSION_USER'); \n" +
"      rec.JN_APPLN := SYS_CONTEXT ('USERENV', 'MODULE'); \n" +
"      rec.JN_SESSION := SYS_CONTEXT ('USERENV', 'SESSIONID'); \n" +
"      IF INSERTING THEN \n" +
"        rec.JN_OPERATION := 'INS'; \n" +
"      ELSIF UPDATING THEN \n" +
"        rec.JN_OPERATION := 'UPD'; \n" +
"      END IF; \n" +
"    ELSIF DELETING THEN \n" ;
for(var i=0;i<cols.length;i++){
	col = cols[i];
	ddl = ddl + "      rec."+col.getName()+" := :OLD."+col.getName()+"; \n";
}
ddl = ddl +
"      rec.JN_DATETIME := SYSDATE; \n" +
"      rec.JN_ORACLE_USER := SYS_CONTEXT ('USERENV', 'SESSION_USER'); \n" +
"      rec.JN_APPLN := SYS_CONTEXT ('USERENV', 'MODULE'); \n" +
"      rec.JN_SESSION := SYS_CONTEXT ('USERENV', 'SESSIONID'); \n" +
"      rec.JN_OPERATION := 'DEL'; \n" +
"    END IF; \n" +
"    INSERT into "+lname+"_JN"+" VALUES rec; \n" +
"  END; \n" +
"  /"
ddlStatementsList.add(new java.lang.String(ddl));]]>
		</script>
	</scr>
	<scr id="DC383793-5C2E-F62A-5241-35B8ACE86134" name="End Of Script" object="null" engine="Oracle Nashorn" type="" var="model" library="" method="" purpose="ddl_transformation" >
		<script>
			<![CDATA[]]>
		</script>
	</scr>
	<scr id="1C0CDD35-A0D6-47E5-C702-7FB537C8A8C0" name="Instead Of Create" object="null" engine="Oracle Nashorn" type="" var="model" library="" method="" purpose="ddl_transformation" >
		<script>
			<![CDATA[]]>
		</script>
	</scr>
	<scr id="0DC38187-8245-8904-7E00-D4B6DF394899" name="Before Create" object="null" engine="Oracle Nashorn" type="" var="model" library="" method="" purpose="ddl_transformation" >
		<script>
			<![CDATA[]]>
		</script>
	</scr>
	<scr id="83D0D285-DF95-0BE7-EF4F-AC3F2D9CDE94" name="After Create" object="null" engine="Oracle Nashorn" type="" var="model" library="" method="" purpose="ddl_transformation" >
		<script>
			<![CDATA[ddl = "-- After Create script example for table " +table.getLongName();
ddlStatementsList.add(new java.lang.String(ddl));]]>
		</script>
	</scr>
	<scr id="6FDC20F3-D5B1-9711-C93F-745217AC8664" name="End Of Script" object="null" engine="Oracle Nashorn" type="" var="model" library="" method="" purpose="ddl_transformation" >
		<script>
			<![CDATA[]]>
		</script>
	</scr>
	<scr id="27EEAD3F-3367-9D6F-8E02-D44189C855A1" name="Instead Of Create" object="null" engine="Oracle Nashorn" type="" var="model" library="" method="" purpose="ddl_transformation" >
		<script>
			<![CDATA[]]>
		</script>
	</scr>
	<scr id="B9B01780-AA07-A433-58F9-92F2E97272D7" name="Before Create" object="null" engine="Oracle Nashorn" type="" var="model" library="TJRS lib" method="generateSQLConfiguration" purpose="ddl_transformation" >
		<script>
			<![CDATA[// Variable used to return custom message
var ruleMessage;
  
// Variables used to return the type of the ruler Error
// or Warning and red/blue  color will be used for result
// if another custom type is returned (Problem in the rule below)
// then result is colored in yellow.
var errType;

/*============================================================================*/

function versaoBiblioteca() {
  var versao = "Versão: 1.0.21.01.2019";
  var titulo = "TJRS - Biblioteca de scripts";

  javax.swing.JOptionPane
     .showMessageDialog
     (null, 
      versao,
      titulo,
      javax.swing.JOptionPane.INFORMATION_MESSAGE
     );
}

/*============================================================================*/

/**
 * Validate the index name, through a ReGex, based on the following
 * document:
 * https://www.tjrs.gov.br/sistemas/redmine/projects/dc34vcqwe4/wiki/Padr%C3%A3o_de_Nome_de_Objetos_de_Banco_de_Dados
 * Parameter
 *   pIndex: a index object
 * Returns
 *   Boolean. True if the index name conforms to index name rule, 
 *            otherwise False.
 */
function isValidIndexName(pIndex) {
   /**
    * Regular expression to match an index name
    * For more information, acess: https://regex101.com/r/aA8hI6/1
    * 
    * Rationale: ^IDX\_.+\_\d{2}$ or /^PK\_.+\_\d{2}$/i
    *   ^ asserts position at start of a line
    *   IDX matches the characters IDX literally (case sensitive)
    *   \_ matches the character _ literally (case sensitive)
    *   .+ matches any character (except for line terminators)
    *   + Quantifier — Matches between one and unlimited times, as many times as possible, giving back as needed (greedy)
    *   \_ matches the character _ literally (case sensitive)
    *   \d{2} matches a digit (equal to [0-9])
    *   {2} Quantifier — Matches exactly 2 times
    *   $ asserts position at the end of a line
    */
   regexp = (pIndex.isPK() ? /^PK\_.+\_\d{2}$/i : /^IDX\_.+\_\d{2}$/i);
   
   return regexp.test(pIndex.getName());
}

/*============================================================================*/

/**
 * Pad zeros to a given number
 * 
 * Parameters
 *   num: a number to be paded
 *   size: leftmost zeroes to pad
 * Returns
 *   The number with leftmost zeroes
 */
function pad(num, size) {
   var s = num+"";
   while (s.length < size) s = "0" + s;
   return s;
}

/*============================================================================*/

/**
 * This Design rule aims to spot indexes, which as not compliance
 * with name formation rule.
 * 
 * Parameters
 *    table: a given table object
 * Returns
 *    Boolean. True if the design rule is satisfied,
 *             otherwise False.
 */
function indexWithInvalidName(table) {

  // Stores the result of this custom
  // design rule.
  result  = true;  

  // Stores the list of table's keys, 
  // and then iterate over it.
  indexes = table.getKeys();
  
  for (var i = 0; i < indexes.length; i++) {
    index = indexes[i];
    if (!index.isPK()){
    	 if (!isValidIndexName(index)) {
    	   ruleMessage  = "The index " + index.getName();
    	   ruleMessage += " has an invalid name. It must be IDX_"
    	   ruleMessage += table.getName() + "_NN, where NN is a two digits number.";
    	   errType = "Error";
    	   return false;
    	 }
    }
  }
  return result;
}

/*============================================================================*/

/**
 * This Design rule aims to spot foreign key constraints which
 * have no index to support it.
 * 
 * Parameters
 *   table: a given table object
 * Returns
 *    Boolean. True if the design rule is satisfied,
 *             otherwise False.
 */
function FKWithOutIndex(table) {

  // Stores the list of table's keys, 
  // and then iterate over it.
  indexes       = table.getKeys();

  // Stores the result of this custom
  // design rule.
  result        = true;

  // Helps to control message text composition.
  newIndexCount = 0;

  // The error message template.
  ruleMessage   = "There is no index for constraint(s):";
	
  // Return an index reference for a given table and
  // column set
  function getIndex(tab,cols){
    keys = tab.getKeys();
    for (var i = 0; i < keys.length; i++) {
      indexTmp = keys[i];
      if(!(indexTmp.isPK() || indexTmp.isUnique()) && !indexTmp.isFK() && indexTmp.isIndexForColumns(cols)){
        return indexTmp
      }
    }
    return null;
  }
  
  for (var i = 0; i < indexes.length; i++) {
    index = indexes[i];
    if (index.isFK()){
      columns = index.getColumns();
      if (columns.length>0){
        newIndex = getIndex(table,columns);
        if (newIndex==null){
          separator    = (++newIndexCount > 1) ? "; " : " ";          
          ruleMessage += separator + index.getName();
          errType      = "Error";
          result       = false;
        }
      }
    }
  }
  return result;
}

/*============================================================================*/

/**
 * This custom transformation aims to spot FKs with have no index
 * and then create the index definition to support it.
 */
function createIndexOnFK() {
  function getIndex(tab,cols){
   keys = tab.getKeys();
   for (var i = 0; i < keys.length; i++) {
    indexTmp = keys[i];
    if(!(indexTmp.isPK() || indexTmp.isUnique()) && !indexTmp.isFK() && indexTmp.isIndexForColumns(cols)){
       return indexTmp
     }
   }
   return null;
  }
  
  // Variable to store sequences for index name for
  // each table from the model. This sequence will be used
  // to form the index name, when it does not follow the naming
  // formation rule.
  var tablesIndexSequence;
  
  tables = model.getTableSet().toArray();
  for (var t = 0; t<tables.length;t++){
    table = tables[t];
    tablesIndexSequence = 0;
    indexes = table.getKeys();
    for (var i = 0; i < indexes.length; i++) {
       index = indexes[i];
       if(index.isFK()){
        columns = index.getColumns();
        if(columns.length>0){
          newIndex = getIndex(table,columns);       
          if(newIndex==null){         
            newIndex = table.createIndex();
            newIndex.setName('IDX_' + table.getName() + '_' + pad(++tablesIndexSequence, 2));
            table.setDirty(true);
            for (var k = 0; k < columns.length; k++){
              newIndex.add(columns[k]);
            }
          }
        }
      }
    }
  }
}

/*============================================================================*/

/**
 * This custom transformation aims to spot invalid index names, and then
 * normalize its name according to name formation rules.
 * 
 * See https://www.tjrs.gov.br/sistemas/redmine/projects/dc34vcqwe4/wiki/Padr%C3%A3o_de_Nome_de_Objetos_de_Banco_de_Dados
 */
function normalizeIndexName() {
  // Variable to store sequences for index name for
  // each table from the model. This sequence will be used
  // to form the index name, when it does not follow the naming
  // formation rule.
  var tablesIndexSequence;

  // Search for the highest index sequence by
  // transversing pIndexes array;
  function initIndexSequence(pIndexes, pTable) {

  	indexSequenceTmp = 1;
  	indexSequenceRet = 1;
  	colision         = false;
  	  	
  	for (var seq = 0; seq < pIndexes.length; seq++) {
  		indexTmp = pIndexes[seq];

          // Discard PK index in search of highest index
          // sequence.
  		if (!indexTmp.isPK()) {
  		   indexNameTmp = "IDX_" + pTable.getName() + "_" + pad(indexSequenceTmp++, 2);
  		   indexTmp     = null;
  		   indexTmp     = pTable.getIndexByName(indexNameTmp);

  		   if (indexTmp != null) {
  			 indexSequenceRet = indexSequenceTmp;
  			 colision = true;
  		   }
  	     }
  	}

  	return (colision ? indexSequenceRet : 1);
  }

  tables = model.getTableSet().toArray();
  for (var t = 0; t < tables.length; t++) {
  	tableTmp = tables[t];
     indexes  = tableTmp.getKeys();
     tablesIndexSequence = initIndexSequence(indexes, tableTmp);
     for (var i = 0; i < indexes.length; i++) {
        index = indexes[i];             
        if (!isValidIndexName(index)) {
        	// Set the new index name based on naming rule.
        	// For PK index, the sequence will be discarded.
          //index.setName((index.isPK() ? "PK_" : "IDX_") + tableTmp.getName() + "_" + pad(tablesIndexSequence++, 2));

          index.setName((index.isPK() ? "PK_" : "IDX_") + tableTmp.getName() + (index.isPK() ? "" : "_" + pad(tablesIndexSequence++, 2)));
          
          tableTmp.setDirty(true);
        }
     }
  }
}

/*============================================================================*/

/**
 * This Design rule aims to spot table which
 * have no primary key.
 * 
 * Parameters
 *   table: a given table object
 * Returns
 *    Boolean. True if the design rule is satisfied,
 *             otherwise False.
 */
function tableWithOutPK(table) {

  // Stores the result of this custom
  // design rule.
  result        = true;

  // Try to retrieve the table's PK.
  pk = table.getPK();

  if (pk == null) {
  	ruleMessage = "there is no primary key for this table.";
     errType     = "Error";
     result      = false;
  }

  return result;
}

/*============================================================================*/

/**
 * This Design rule aims to spot table which
 * have no expected volume registered in the model.
 * 
 * Parameters
 *   table: a given table object
 * Returns
 *    Boolean. True if the design rule is satisfied,
 *             otherwise False.
 */

function tableWithOutVolumetry(table) {

  // Stores the result of this custom
  // design rule.
  result        = true;	

  // Get the expected amount of rows
  expectedVolume = table.getExpectedVolumes();

  if (expectedVolume == 0 || expectedVolume == null) {
  	ruleMessage = "the table property 'Expected' cannot be 0 or null. Check table's Volume Properties.";
     errType     = "Error";
     result      = false;
  }

  return result;  
}

/*============================================================================*/

/**
 * This Design rule aims to spot table which
 * have no expected volume property registered in the model.
 * 
 * Parameters
 *   table: a given table object
 * Returns
 *    Boolean. True if the design rule is satisfied,
 *             otherwise False.
 */

function tableWithOutVolumetry(table) {

  // Stores the result of this custom
  // design rule.
  result        = true;	

  // Get the expected amount of rows
  expectedVolume = table.getExpectedVolumes();

  if (expectedVolume == 0 || expectedVolume == null) {
  	ruleMessage = "the table property 'Expected' cannot be 0 or null. Check table's Volume Properties.";
     errType     = "Error";
     result      = false;
  }

  return result;  
}

/*============================================================================*/

/**
 * This Design rule aims to spot table which
 * have no compression property assigned to it.
 * 
 * Parameters
 *   table: a given table object
 * Returns
 *    Boolean. True if the design rule is satisfied,
 *             otherwise False.
 */

function tableWithOutDataCompression(table) {

  // Stores the result of this custom
  // design rule.
  result        = true;	

  // Get the expected amount of rows
  expectedVolume = table.getExpectedVolumes();

  if (expectedVolume == 0 || expectedVolume == null) {
  	ruleMessage = "the table property 'Expected' cannot be 0 or null. Check table's Volume Properties.";
     errType     = "Error";
     result      = false;
  }

  return result;  
}

/**
 * The goal of this custom transformation is to modify SQL command line
 * session to set stop running the script on failure behavior and force
 * the current schema to avoid to create the object in the wrong schema.
 *
 */
function generateSQLConfiguration() {
	var cfgDDL;
	var modelTmp = model;
	cfgDDL  = "PROMPT Configuracao do ambiente de execucao do SQL\n";
	cfgDDL += "WHENEVER SQLERROR EXIT FAILURE;\n";
	cfgDDL += "SET SCAN OFF;\n";
	cfgDDL += "ALTER SESSION SET CURRENT_SCHEMA=[" +  "];\n\n";
	
	// Add the configuration at the begining of DDL script
	ddlStatementsList.add(new java.lang.String(cfgDDL));
}]]>
		</script>
	</scr>
	<scr id="82E2A003-E149-0C58-0BE9-0F8DCE476F39" name="Instead Of Create" object="null" engine="Oracle Nashorn" type="" var="model" library="" method="" purpose="ddl_transformation" >
		<script>
			<![CDATA[]]>
		</script>
	</scr>
	<scr id="CBC5F1A0-943E-59B6-2704-628565749E21" name="After Create" object="null" engine="Oracle Nashorn" type="" var="model" library="" method="" purpose="ddl_transformation" >
		<script>
			<![CDATA[]]>
		</script>
	</scr>
	<scr id="4C4DAF7D-51E6-95A5-55E5-08280F999D95" name="End Of Script" object="null" engine="Oracle Nashorn" type="" var="model" library="" method="" purpose="ddl_transformation" >
		<script>
			<![CDATA[]]>
		</script>
	</scr>
	<scr id="D36CE536-D575-BE5C-625F-23DE23913C6B" name="Complex rule - check comments demo" object="Table" engine="Oracle Nashorn" type="Warning" var="table" library="my first library" method="checkcomments" purpose="validation" >
		<script>
			<![CDATA[]]>
		</script>
	</scr>
	<scr id="D72E63EC-9DA2-3537-F8C9-AE8ACEDC73D2" name="Length of Not Null Constraint name" object="Column" engine="Oracle Nashorn" type="Error" var="column" library="my first library" method="NotNullConstr_Name_Length" purpose="validation" >
		<script>
			<![CDATA[]]>
		</script>
	</scr>
	<scr id="3F2B77AE-F97F-EF6D-4D6D-C9FE4CC78999" name="Optional FK with mandatory columns" object="Index/Constraint" engine="Oracle Nashorn" type="Warning" var="index" library="" method="" purpose="validation" >
		<script>
			<![CDATA[var index;
// define function - function parameter doesn't need to be named index
function checkFKColumns(index){
  //check it's foreign key index, otherwise FK is null
 if(index.isFK()){
 	if(!index.getFKAssociation().isMandatory()){
	 cols = index.getElements();
	 for(var i=0;i<cols.length;i++){
		if(cols[i].isMandatory()){
			return false;
		}
	 }
 	}
 }
 return true;
}
// invoke the function
checkFKColumns(index);]]>
		</script>
	</scr>
	<scr id="273541C2-9F46-A972-510C-146B117AE338" name="TJRS - Index with invalid name" object="Table" engine="Oracle Nashorn" type="Error" var="table" library="TJRS lib" method="indexWithInvalidName" purpose="validation" >
		<script>
			<![CDATA[]]>
		</script>
	</scr>
	<scr id="4091D7C0-AD54-B648-024F-FDD7E7B7D401" name="TJRS - FK without index" object="Table" engine="Oracle Nashorn" type="Error" var="table" library="TJRS lib" method="FKWithOutIndex" purpose="validation" >
		<script>
			<![CDATA[]]>
		</script>
	</scr>
	<scr id="50E1AC25-597E-FF23-9B08-30AFB6C83D10" name="TJRS - Versao da biblioteca de scripts" object="Domain" engine="Oracle Nashorn" type="Warning" var="domain" library="TJRS lib" method="versaoBiblioteca" purpose="validation" >
		<script>
			<![CDATA[]]>
		</script>
	</scr>
	<scr id="B0F0E2CA-6F41-463F-73A0-17FB99716AC6" name="TJRS - Tables without primary key" object="Table" engine="Oracle Nashorn" type="Error" var="table" library="TJRS lib" method="tableWithOutPK" purpose="validation" >
		<script>
			<![CDATA[]]>
		</script>
	</scr>
	<scr id="D52311F1-3FF2-EA90-8157-86E7A7C03776" name="TJRS - Tables without volumetry" object="Table" engine="Oracle Nashorn" type="Error" var="table" library="TJRS lib" method="tableWithOutVolumetry" purpose="validation" >
		<script>
			<![CDATA[]]>
		</script>
	</scr>
	<scr id="756DE154-799A-42CB-7E46-A162B768E6B6" name="TJRS - Tables with wrong tablespace usage" object="Table" engine="Oracle Nashorn" type="Error" var="table" library="TJRS lib" method="validateTableTablespaceUsage" purpose="validation" >
		<script>
			<![CDATA[]]>
		</script>
	</scr>
	<scr id="679189F6-E6A8-5409-FEA3-31B6DC8A462D" name="TJRS - Sequences with NOCACHE" object="Table" engine="Oracle Nashorn" type="Warning" var="table" library="TJRS lib" method="sequencesWithNOCACHE" purpose="validation" >
		<script>
			<![CDATA[]]>
		</script>
	</scr>
	<scr id="0BAA564F-AB5F-D776-2E4F-31FDB3047F69" name="Tables to lower case - Rhino" object="relational" engine="Oracle Nashorn" type="" var="model" library="" method="" purpose="transformation" >
		<script>
			<![CDATA[tables = model.getTableSet().toArray();
for (var t = 0; t<tables.length;t++){
 table = tables[t];
 name = table.getName().toLowerCase();
 table.setName(name);
 columns = table.getElements();
 size = table.getElementsCollection().size();
 for (var i = 0; i < size; i++) {
	column = columns[i];
	cname = column.getName().toLowerCase();
	column.setName(cname);
 }
 table.setDirty(true);
 keys = table.getKeys();
 for (var i = 0; i < keys.length; i++) {
  key = keys[i];
    if(!key.isFK()){
     kname = key.getName().toLowerCase();
     key.setName(kname);
   }else{
     kname = key.getFKAssociation().getName().toLowerCase();
     key.getFKAssociation().setName(kname);
     key.getFKAssociation().setDirty(true);
   }
 }
}]]>
		</script>
	</scr>
	<scr id="B673F271-4836-DD48-15AC-487DDECCAF49" name="Tables to upper case - JRuby" object="relational" engine="JSR 223 JRuby Engine" type="" var="model" library="" method="" purpose="transformation" >
		<script>
			<![CDATA[tables =$model.getTableSet().toArray()
for t in 0..tables.length-1
 table = tables[t]
 name = table.getName().upcase
 table.setName(name)
 columns = table.getElements()
 size = table.getElementsCollection().size()-1
 for i in 0..size
	column = columns[i]
	cname = column.getName().upcase
	column.setName(cname)
 end
 keys = table.getKeys()
 for i in 0..keys.length-1
  key = keys[i]
  kname = key.getName().upcase
  key.setName(kname)
 end
end]]>
		</script>
	</scr>
	<scr id="3E7C4F9E-9FCB-56C7-086F-F976F9A66384" name="Tables to upper case - JRuby - library usage" object="relational" engine="JSR 223 JRuby Engine" type="" var="model" library="Jruby lib" method="tables_up" purpose="transformation" >
		<script>
			<![CDATA[def tables_up(model)
tables = model.getTableSet().toArray()
for t in 0..tables.length-1
 table = tables[t]
 name = table.getName().upcase
 table.setName(name)
 columns = table.getElements()
 size = table.getElementsCollection().size()-1
 for i in 0..size
	column = columns[i]
	cname = column.getName().upcase
	column.setName(cname)
 end
 keys = table.getKeys()
 for i in 0..keys.length-1
  key = keys[i]
  kname = key.getName().upcase
  key.setName(kname)
 end
end
return true
end]]>
		</script>
	</scr>
	<scr id="E60A5A28-BB9B-3787-10E7-259DF900B9E6" name="Table abbreviation to column" object="relational" engine="Oracle Nashorn" type="" var="model" library="" method="" purpose="transformation" >
		<script>
			<![CDATA[tables = model.getTableSet().toArray();
for (var t = 0; t<tables.length;t++){
 table = tables[t];
 abbr = table.getAbbreviation()+"_";
 if(!"_".equals(abbr)){
     columns = table.getElements();
     for (var i = 0; i < columns.length; i++) {
        column = columns[i];
        cname = column.getName();
        if(!cname.startsWith(abbr)){
         column.setName(abbr+cname);
        }
     }
 }
}]]>
		</script>
	</scr>
	<scr id="9BE4E26C-36D8-A92C-ADEA-F183327DC239" name="Remove Table abbr from column" object="relational" engine="Oracle Nashorn" type="" var="model" library="" method="" purpose="transformation" >
		<script>
			<![CDATA[tables = model.getTableSet().toArray();
for (var t = 0; t<tables.length;t++){
 table = tables[t];
 abbr = table.getAbbreviation()+"_";
 count = table.getAbbreviation().length()+1;
 if(!"_".equals(abbr)){
     columns = table.getElements();
     for (var i = 0; i < columns.length; i++) {
        column = columns[i];
        cname = column.getName();
        if(cname.startsWith(abbr)){
         column.setName(cname.substring(count));
         table.setDirty(true);
        }
     }
 }
}]]>
		</script>
	</scr>
	<scr id="5A8A151A-13FD-4B0A-E233-E3C5126BA02C" name="Tables to upper case - Rhino" object="relational" engine="Oracle Nashorn" type="" var="model" library="" method="" purpose="transformation" >
		<script>
			<![CDATA[tables = model.getTableSet().toArray();
for (var t = 0; t<tables.length;t++){
 table = tables[t];
 name = table.getName().toUpperCase();
 table.setName(name);
 columns = table.getElements();
 size = table.getElementsCollection().size();
 for (var i = 0; i < size; i++) {
	column = columns[i];
	cname = column.getName().toUpperCase();
	column.setName(cname);
 }
 table.setDirty(true);
 keys = table.getKeys();
 for (var i = 0; i < keys.length; i++) {
  key = keys[i];
    if(!key.isFK()){
     kname = key.getName().toUpperCase();
     key.setName(kname);
   }else{
     kname = key.getFKAssociation().getName().toUpperCase();
     key.getFKAssociation().setName(kname);
     key.getFKAssociation().setDirty(true);
   }
 }
}]]>
		</script>
	</scr>
	<scr id="0528C35C-F29B-E7BB-57AC-37BA2780A98D" name="Table template - uses column name" object="relational" engine="Oracle Nashorn" type="" var="model" library="" method="" purpose="transformation" >
		<script>
			<![CDATA[// columns are found by column name
// allowing reuse of already existing columns
// dynamic property ctemplateID is set afterwards - will keep connection to template
// column even if the name of column is changed
var t_name = "table_template";
var p_name = "ctemplateID";
template = model.getTableSet().getByName(t_name);
if(template!=null){
    tcolumns = template.getElements();
    tables = model.getTableSet().toArray();
    for (var t = 0; t<tables.length;t++){
     table = tables[t];
    // compare name ignoring the case
     if(!table.getName().equalsIgnoreCase(t_name)){
         for (var i = 0; i < tcolumns.length; i++) {
            column = tcolumns[i];
            col = table.getElementByName(column.getName());
            if(col==null){
             col = table.getColumnByProperty(p_name,column.getObjectID());
            }
            if(col==null){
             col = table.createColumn();
            }
            column.copy(col);
            //set property after copy otherwise it'll be cleared by copy
            col.setProperty(p_name,column.getObjectID());
            table.setDirty(true);
         }
     }
    }
}]]>
		</script>
	</scr>
	<scr id="6279C414-90DD-A52B-4CEB-8D49AB31DC10" name="Copy Comments to Comments in RDBMS" object="relational" engine="Oracle Nashorn" type="" var="model" library="" method="" purpose="transformation" >
		<script>
			<![CDATA[max_length = 4000;
function copyComments(object){
 if(object.getCommentInRDBMS().equals("")){
   if(!object.getComment().equals("")){
     if(object.getComment().length()>max_length){
       object.setCommentInRDBMS(object.getComment().substring(0, max_length));
     }else{
       object.setCommentInRDBMS(object.getComment());
     }
     object.setDirty(true);
   }
 }
}

tables = model.getTableSet().toArray();
for (var t = 0; t<tables.length;t++){
 table = tables[t]
 copyComments(table);
 columns = table.getElements();
 size = table.getElementsCollection().size();
 for (var i = 0; i < columns.length; i++) {
	column = columns[i];
	copyComments(column);
 }
 keys = table.getKeys();
 for (var i = 0; i < keys.length; i++) {
   key = keys[i];
   if(!key.isFK()){
     copyComments(key);
   }else{
     copyComments(key.getFKAssociation());
   }
 }
}]]>
		</script>
	</scr>
	<scr id="1726EC74-A64B-0C0F-83DB-2A4BEF0D3DCA" name="Columns order" object="relational" engine="Oracle Nashorn" type="" var="model" library="" method="" purpose="transformation" >
		<script>
			<![CDATA[// sorts table columns as asked here https://forums.oracle.com/forums/thread.jspa?threadID=2508315&tstart=0
// "...first the pks columns, after them fk columns and after the not null columns"
function addPKcolumns(list,table){
	pk = table.getPK();
	if(pk!=null){
		pcols = pk.getColumns();
		for(var i = 0;i<pcols.length;i++){
			col = pcols[i];
			//in fact don't need this check, because PK columns are processed first
			if(!list.contains(col)){
				list.add(col);
			}
		}
	}
}

function addFKcolumns(list,fkeys){
	for(var k=0;k<fkeys.length;k++){
		fcols = fkeys[k].getColumns();
		for(var i = 0;i<fcols.length;i++){
		  col = fcols[i];
		  if(!list.contains(col)){
			list.add(col);
		  }
		}
	}
}
//adds mandatory or oprional columns to list depending on mand parameter
function addMandatoryOptColumns(list,cols, mand){
	for(var i = 0;i<cols.length;i++){
		col = cols[i];
		if(col.isMandatory() == mand && !list.contains(col)){
			list.add(col);
		}
	}
}

tables = model.getTableSet().toArray();
list = new java.util.ArrayList();
for (var t = 0; t<tables.length;t++){
	list.clear();
	table = tables[t];
	cols = table.getElements();
	// add PK columns to list
	addPKcolumns(list,table);
	// add FK columns to list
	addFKcolumns(list,table.getFKAssociations());
	//add mandatory columns
	addMandatoryOptColumns(list,cols,true);
	//add optional columns
	addMandatoryOptColumns(list,cols,false);
	//use list to reorder columns
	ord_cols = list.toArray();
	for(var n = 0;n<ord_cols.length;n++){
		table.moveToIndex(ord_cols[n],n);
	}
	//prevent reordering from enginnering, can be changed with UI
	table.setAllowColumnReorder(false);
	table.setDirty(true);
}]]>
		</script>
	</scr>
	<scr id="F54B1A9C-F951-EB88-E905-5599533569B1" name="Create subview from tables in serch result " object="relational" engine="Oracle Nashorn" type="" var="model" library="" method="" purpose="transformation" >
		<script>
			<![CDATA[objs = model.getLastSearchResult().toArray();
var dp;
var sv;
//create subview and add tables to it
for(var i = 0;i<objs.length;i++){
	obj = objs[i];
	// use "Entity" for entities and logical model
	if(obj.getObjectTypeName().equals("Table")){
		if(dp==null){
			dp = obj.getDesignPart();
			sv = dp.createDesignPartSubView();
			// uncomment next line if want to set name
		     //sv.setName("Name");
		     sv.getPlaceHolder().setVisible(true);
		}
		sv.addViewFor(obj);
	}
}
if(dp!=null){
 //add foreign keys if you want to
 for(var i = 0;i<objs.length;i++){
	obj = objs[i];
	// use "Entity" for entities and logical model
	if(obj.getObjectTypeName().equals("Table")){
		tv = obj.getFirstViewForDPV(sv);
		if(tv!=null){
			//for entities and logical model use 
			//tv.addTVRelations(); 
			tv.addTVFKRelations();
		}
	}
 }
 //add Arcs if you want to
 for(var i = 0;i<objs.length;i++){
	obj = objs[i];
	if(obj.getObjectTypeName().equals("Table")){
		tv = obj.getFirstViewForDPV(sv);
		if(tv!=null){
			tv.addArcs();
		}
	}
 }
 //arrange diagram
 sv.rearrangeNewDiagram();
}]]>
		</script>
	</scr>
	<scr id="EF64BEDD-B648-C41B-60C7-B9EA938E0A3C" name="Remove template columns and related attributes" object="relational" engine="Oracle Nashorn" type="" var="model" library="" method="" purpose="transformation" >
		<script>
			<![CDATA[/* removes the columns created with "Table template..." script, also removes related attributes
*  from logical model
*  more details here http://www.thatjeffsmith.com/archive/2015/03/adding-common-columns-to-tables-via-templates-and-transformation-scripts/
*/
var t_name = "table_template";
var p_name = "ctemplateID";
template = model.getTableSet().getByName(t_name);
if(template!=null){
    tcolumns = template.getElements();
    tables = model.getTableSet().toArray();
    for (var t = 0; t<tables.length;t++){
     table = tables[t];
    // compare name ignoring the case
     if(!table.getName().equalsIgnoreCase(t_name)){
         for (var i = 0; i < tcolumns.length; i++) {
            column = tcolumns[i];
            col = table.getColumnByProperty(p_name,column.getObjectID());
            if(col!=null){
            	attr = col.getEngAttribute();
            	if(attr!=null){
            		ent = attr.getEntity();
            		attr.remove();
            		if(ent!=null){
            			ent.setDirty(true);
            		}
            	}
             col.remove();
             table.setDirty(true);
            }
         }
     }
    }
}]]>
		</script>
	</scr>
	<scr id="19696CD4-6A15-011E-8E18-30F17EC4F28B" name="TJRS - Versao da biblioteca de scripts" object="relational" engine="Oracle Nashorn" type="" var="model" library="TJRS lib" method="versaoBiblioteca" purpose="transformation" >
		<script>
			<![CDATA[// Variable used to return custom message
var ruleMessage;
  
// Variables used to return the type of the ruler Error
// or Warning and red/blue  color will be used for result
// if another custom type is returned (Problem in the rule below)
// then result is colored in yellow.
var errType;

/*============================================================================*/

function versaoBiblioteca() {
  var versao = "Versão: 1.0.21.01.2019";
  var titulo = "TJRS - Biblioteca de scripts";

  javax.swing.JOptionPane
     .showMessageDialog
     (null, 
      versao,
      titulo,
      javax.swing.JOptionPane.INFORMATION_MESSAGE
     );
}

/*============================================================================*/

/**
 * Validate the index name, through a ReGex, based on the following
 * document:
 * https://www.tjrs.gov.br/sistemas/redmine/projects/dc34vcqwe4/wiki/Padr%C3%A3o_de_Nome_de_Objetos_de_Banco_de_Dados
 * Parameter
 *   pIndex: a index object
 * Returns
 *   Boolean. True if the index name conforms to index name rule, 
 *            otherwise False.
 */
function isValidIndexName(pIndex) {
   /**
    * Regular expression to match an index name
    * For more information, acess: https://regex101.com/r/aA8hI6/1
    * 
    * Rationale: ^IDX\_.+\_\d{2}$ or /^PK\_.+\_\d{2}$/i
    *   ^ asserts position at start of a line
    *   IDX matches the characters IDX literally (case sensitive)
    *   \_ matches the character _ literally (case sensitive)
    *   .+ matches any character (except for line terminators)
    *   + Quantifier — Matches between one and unlimited times, as many times as possible, giving back as needed (greedy)
    *   \_ matches the character _ literally (case sensitive)
    *   \d{2} matches a digit (equal to [0-9])
    *   {2} Quantifier — Matches exactly 2 times
    *   $ asserts position at the end of a line
    */
   regexp = (pIndex.isPK() ? /^PK\_.+\_\d{2}$/i : /^IDX\_.+\_\d{2}$/i);
   
   return regexp.test(pIndex.getName());
}

/*============================================================================*/

/**
 * Pad zeros to a given number
 * 
 * Parameters
 *   num: a number to be paded
 *   size: leftmost zeroes to pad
 * Returns
 *   The number with leftmost zeroes
 */
function pad(num, size) {
   var s = num+"";
   while (s.length < size) s = "0" + s;
   return s;
}

/*============================================================================*/

/**
 * This Design rule aims to spot indexes, which as not compliance
 * with name formation rule.
 * 
 * Parameters
 *    table: a given table object
 * Returns
 *    Boolean. True if the design rule is satisfied,
 *             otherwise False.
 */
function indexWithInvalidName(table) {

  // Stores the result of this custom
  // design rule.
  result  = true;  

  // Stores the list of table's keys, 
  // and then iterate over it.
  indexes = table.getKeys();
  
  for (var i = 0; i < indexes.length; i++) {
    index = indexes[i];
    if (!index.isPK()){
    	 if (!isValidIndexName(index)) {
    	   ruleMessage  = "The index " + index.getName();
    	   ruleMessage += " has an invalid name. It must be IDX_"
    	   ruleMessage += table.getName() + "_NN, where NN is a two digits number.";
    	   errType = "Error";
    	   return false;
    	 }
    }
  }
  return result;
}

/*============================================================================*/

/**
 * This Design rule aims to spot foreign key constraints which
 * have no index to support it.
 * 
 * Parameters
 *   table: a given table object
 * Returns
 *    Boolean. True if the design rule is satisfied,
 *             otherwise False.
 */
function FKWithOutIndex(table) {

  // Stores the list of table's keys, 
  // and then iterate over it.
  indexes       = table.getKeys();

  // Stores the result of this custom
  // design rule.
  result        = true;

  // Helps to control message text composition.
  newIndexCount = 0;

  // The error message template.
  ruleMessage   = "There is no index for constraint(s):";
	
  // Return an index reference for a given table and
  // column set
  function getIndex(tab,cols){
    keys = tab.getKeys();
    for (var i = 0; i < keys.length; i++) {
      indexTmp = keys[i];
      if(!(indexTmp.isPK() || indexTmp.isUnique()) && !indexTmp.isFK() && indexTmp.isIndexForColumns(cols)){
        return indexTmp
      }
    }
    return null;
  }
  
  for (var i = 0; i < indexes.length; i++) {
    index = indexes[i];
    if (index.isFK()){
      columns = index.getColumns();
      if (columns.length>0){
        newIndex = getIndex(table,columns);
        if (newIndex==null){
          separator    = (++newIndexCount > 1) ? "; " : " ";          
          ruleMessage += separator + index.getName();
          errType      = "Error";
          result       = false;
        }
      }
    }
  }
  return result;
}

/*============================================================================*/

/**
 * This custom transformation aims to spot FKs with have no index
 * and then create the index definition to support it.
 */
function createIndexOnFK() {
  function getIndex(tab,cols){
   keys = tab.getKeys();
   for (var i = 0; i < keys.length; i++) {
    indexTmp = keys[i];
    if(!(indexTmp.isPK() || indexTmp.isUnique()) && !indexTmp.isFK() && indexTmp.isIndexForColumns(cols)){
       return indexTmp
     }
   }
   return null;
  }
  
  // Variable to store sequences for index name for
  // each table from the model. This sequence will be used
  // to form the index name, when it does not follow the naming
  // formation rule.
  var tablesIndexSequence;
  
  tables = model.getTableSet().toArray();
  for (var t = 0; t<tables.length;t++){
    table = tables[t];
    tablesIndexSequence = 0;
    indexes = table.getKeys();
    for (var i = 0; i < indexes.length; i++) {
       index = indexes[i];
       if(index.isFK()){
        columns = index.getColumns();
        if(columns.length>0){
          newIndex = getIndex(table,columns);       
          if(newIndex==null){         
            newIndex = table.createIndex();
            newIndex.setName('IDX_' + table.getName() + '_' + pad(++tablesIndexSequence, 2));
            table.setDirty(true);
            for (var k = 0; k < columns.length; k++){
              newIndex.add(columns[k]);
            }
          }
        }
      }
    }
  }
}

/*============================================================================*/

/**
 * This custom transformation aims to spot invalid index names, and then
 * normalize its name according to name formation rules.
 * 
 * See https://www.tjrs.gov.br/sistemas/redmine/projects/dc34vcqwe4/wiki/Padr%C3%A3o_de_Nome_de_Objetos_de_Banco_de_Dados
 */
function normalizeIndexName() {
  // Variable to store sequences for index name for
  // each table from the model. This sequence will be used
  // to form the index name, when it does not follow the naming
  // formation rule.
  var tablesIndexSequence;

  // Search for the highest index sequence by
  // transversing pIndexes array;
  function initIndexSequence(pIndexes, pTable) {

  	indexSequenceTmp = 1;
  	indexSequenceRet = 1;
  	colision         = false;
  	  	
  	for (var seq = 0; seq < pIndexes.length; seq++) {
  		indexTmp = pIndexes[seq];

          // Discard PK index in search of highest index
          // sequence.
  		if (!indexTmp.isPK()) {
  		   indexNameTmp = "IDX_" + pTable.getName() + "_" + pad(indexSequenceTmp++, 2);
  		   indexTmp     = null;
  		   indexTmp     = pTable.getIndexByName(indexNameTmp);

  		   if (indexTmp != null) {
  			 indexSequenceRet = indexSequenceTmp;
  			 colision = true;
  		   }
  	     }
  	}

  	return (colision ? indexSequenceRet : 1);
  }

  tables = model.getTableSet().toArray();
  for (var t = 0; t < tables.length; t++) {
  	tableTmp = tables[t];
     indexes  = tableTmp.getKeys();
     tablesIndexSequence = initIndexSequence(indexes, tableTmp);
     for (var i = 0; i < indexes.length; i++) {
        index = indexes[i];             
        if (!isValidIndexName(index)) {
        	// Set the new index name based on naming rule.
        	// For PK index, the sequence will be discarded.
          //index.setName((index.isPK() ? "PK_" : "IDX_") + tableTmp.getName() + "_" + pad(tablesIndexSequence++, 2));

          index.setName((index.isPK() ? "PK_" : "IDX_") + tableTmp.getName() + (index.isPK() ? "" : "_" + pad(tablesIndexSequence++, 2)));
          
          tableTmp.setDirty(true);
        }
     }
  }
}

/*============================================================================*/

/**
 * This Design rule aims to spot table which
 * have no primary key.
 * 
 * Parameters
 *   table: a given table object
 * Returns
 *    Boolean. True if the design rule is satisfied,
 *             otherwise False.
 */
function tableWithOutPK(table) {

  // Stores the result of this custom
  // design rule.
  result        = true;

  // Try to retrieve the table's PK.
  pk = table.getPK();

  if (pk == null) {
  	ruleMessage = "there is no primary key for this table.";
     errType     = "Error";
     result      = false;
  }

  return result;
}

/*============================================================================*/

/**
 * This Design rule aims to spot table which
 * have no expected volume registered in the model.
 * 
 * Parameters
 *   table: a given table object
 * Returns
 *    Boolean. True if the design rule is satisfied,
 *             otherwise False.
 */

function tableWithOutVolumetry(table) {

  // Stores the result of this custom
  // design rule.
  result        = true;	

  // Get the expected amount of rows
  expectedVolume = table.getExpectedVolumes();

  if (expectedVolume == 0 || expectedVolume == null) {
  	ruleMessage = "the table property 'Expected' cannot be 0 or null. Check table's Volume Properties.";
     errType     = "Error";
     result      = false;
  }

  return result;  
}

/*============================================================================*/

/**
 * This Design rule aims to spot table which
 * have no expected volume property registered in the model.
 * 
 * Parameters
 *   table: a given table object
 * Returns
 *    Boolean. True if the design rule is satisfied,
 *             otherwise False.
 */

function tableWithOutVolumetry(table) {

  // Stores the result of this custom
  // design rule.
  result        = true;	

  // Get the expected amount of rows
  expectedVolume = table.getExpectedVolumes();

  if (expectedVolume == 0 || expectedVolume == null) {
  	ruleMessage = "the table property 'Expected' cannot be 0 or null. Check table's Volume Properties.";
     errType     = "Error";
     result      = false;
  }

  return result;  
}

/*============================================================================*/

/**
 * This Design rule aims to spot table which
 * have no compression property assigned to it.
 * 
 * Parameters
 *   table: a given table object
 * Returns
 *    Boolean. True if the design rule is satisfied,
 *             otherwise False.
 */

function tableWithOutDataCompression(table) {

  // Stores the result of this custom
  // design rule.
  result        = true;	

  // Get the expected amount of rows
  expectedVolume = table.getExpectedVolumes();

  if (expectedVolume == 0 || expectedVolume == null) {
  	ruleMessage = "the table property 'Expected' cannot be 0 or null. Check table's Volume Properties.";
     errType     = "Error";
     result      = false;
  }

  return result;  
}]]>
		</script>
	</scr>
	<scr id="C9DFEA82-545A-A8B3-8BC2-FFA80A751179" name="TJRS - Create index on FK" object="relational" engine="Oracle Nashorn" type="" var="model" library="TJRS lib" method="createIndexOnFK" purpose="transformation" >
		<script>
			<![CDATA[// Variable used to return custom message
var ruleMessage;
  
// Variables used to return the type of the ruler Error
// or Warning and red/blue  color will be used for result
// if another custom type is returned (Problem in the rule below)
// then result is colored in yellow.
var errType;

/*============================================================================*/

function versaoBiblioteca() {
  var versao = "1.0.09.11.2018";
  var titulo = "TJRS - Versão da biblioteca";

  javax.swing.JOptionPane
     .showMessageDialog
     (null, 
      versao,
      titulo,
      javax.swing.JOptionPane.INFORMATION_MESSAGE
     );
}

/*============================================================================*/

// Validade the index name, through a ReGex, based on the following
// document:
// https://www.tjrs.gov.br/sistemas/redmine/projects/dc34vcqwe4/wiki/Padr%C3%A3o_de_Nome_de_Objetos_de_Banco_de_Dados
// Parameter
//   pIndex: a index object
// Returns
//   boolean
function isValidIndexName(pIndex) {
   // Regular expression to match an index name
   // For more information, acess: https://regex101.com/r/aA8hI6/1
   // 
   // Rationale: ^IDX\_.+\_\d{2}$ or /^PK\_.+\_\d{2}$/i
   //   ^ asserts position at start of a line
   //   IDX matches the characters IDX literally (case sensitive)
   //   \_ matches the character _ literally (case sensitive)
   //   .+ matches any character (except for line terminators)
   //   + Quantifier — Matches between one and unlimited times, as many times as possible, giving back as needed (greedy)
   //   \_ matches the character _ literally (case sensitive)
   //   \d{2} matches a digit (equal to [0-9])
   //   {2} Quantifier — Matches exactly 2 times
   //   $ asserts position at the end of a line

   regexp = (pIndex.isPK() ? /^PK\_.+\_\d{2}$/i : /^IDX\_.+\_\d{2}$/i);
   
   return regexp.test(pIndex.getName());
}

/*============================================================================*/

// This Design rule aims to spot indexes, which as not compliance
// with name formation rule.
function indexWithInvalidName(table) {

  // Validade the index name, through a ReGex, based on the following
  // document:
  // https://www.tjrs.gov.br/sistemas/redmine/projects/dc34vcqwe4/wiki/Padr%C3%A3o_de_Nome_de_Objetos_de_Banco_de_Dados
  // Parameter
  //   pIndexName: a index name
  // Returns
  //   boolean
  function isValidIndexName(pIndexName) {
  	// Regular expression to match an index name
  	// For more information, acess: https://regex101.com/r/aA8hI6/1
  	// 
  	// Rationale: ^IDX\_.+\_\d{2}$
     //   ^ asserts position at start of a line
     //   IDX matches the characters IDX literally (case sensitive)
     //   \_ matches the character _ literally (case sensitive)
     //   .+ matches any character (except for line terminators)
     //   + Quantifier — Matches between one and unlimited times, as many times as possible, giving back as needed (greedy)
     //   \_ matches the character _ literally (case sensitive)
     //   \d{2} matches a digit (equal to [0-9])
     //   {2} Quantifier — Matches exactly 2 times
     //   $ asserts position at the end of a line  	 
     regexp = /^IDX\_.+\_\d{2}$/i;    	 
    	return regexp.test(pIndexName);
  }
	
  // Stores the result of this custom
  // design rule.
  result  = true;  

  // Stores the list of table's keys, 
  // and then iterate over it.
  indexes = table.getKeys();
  
  for (var i = 0; i < indexes.length; i++) {
    index = indexes[i];
    if (!index.isPK()){
    	 if (!isValidIndexName(index.getName())) {
    	   ruleMessage  = "The index " + index.getName();
    	   ruleMessage += " has an invalid name. It must be IDX_"
    	   ruleMessage += table.getName() + "_NN, where NN is a two digits number.";
    	   errType = "Error";
    	   return false;
    	 }
    }
  }
  return result;
}

/*============================================================================*/

// This Design rule aims to spot foreign key constraints which
// have no index to support it.
function FKWithOutIndex(table) {

  // Stores the list of table's keys, 
  // and then iterate over it.
  indexes       = table.getKeys();

  // Stores the result of this custom
  // design rule.
  result        = true;

  // Helps to control message text composition.
  newIndexCount = 0;

  // The error message template.
  ruleMessage   = "There is no index for constraint(s):";
	
  // Return an index reference for a given table and
  // column set
  function getIndex(tab,cols){
    keys = tab.getKeys();
    for (var i = 0; i < keys.length; i++) {
      indexTmp = keys[i];
      if(!(indexTmp.isPK() || indexTmp.isUnique()) && !indexTmp.isFK() && indexTmp.isIndexForColumns(cols)){
        return indexTmp
      }
    }
    return null;
  }
  
  for (var i = 0; i < indexes.length; i++) {
    index = indexes[i];
    if (index.isFK()){
      columns = index.getColumns();
      if (columns.length>0){
        newIndex = getIndex(table,columns);
        if (newIndex==null){

          separator    = (++newIndexCount > 1) ? "; " : " ";
          
          ruleMessage += separator + index.getName();
          errType      = "Error";
          result       = false;
        }
      }
    }
  }
  return result;
}

/*============================================================================*/

// This custom transformation aims to spot FKs with have no index
// and then create the index definition to support it.

function createIndexOnFK() {
  function getIndex(tab,cols){
   keys = tab.getKeys();
   for (var i = 0; i < keys.length; i++) {
    indexTmp = keys[i];
    if(!(indexTmp.isPK() || indexTmp.isUnique()) && !indexTmp.isFK() && indexTmp.isIndexForColumns(cols)){
       return indexTmp
     }
   }
   return null;
  }
  
  function pad(num, size) {
      var s = num+"";
      while (s.length < size) s = "0" + s;
      return s;
  }
  
  // Variable to store sequences for index name for
  // each table from the model. This sequence will be used
  // to form the index name, when it does not follow the naming
  // formation rule.
  var tablesIndexSequence;
  
  tables = model.getTableSet().toArray();
  for (var t = 0; t<tables.length;t++){
    table = tables[t];
    tablesIndexSequence = 0;
    indexes = table.getKeys();
    for (var i = 0; i < indexes.length; i++) {
       index = indexes[i];
       if(index.isFK()){
        columns = index.getColumns();
        if(columns.length>0){
          newIndex = getIndex(table,columns);       
          if(newIndex==null){         
            newIndex = table.createIndex();
            newIndex.setName('IDX_' + table.getName() + '_' + pad(++tablesIndexSequence, 2));
            table.setDirty(true);
            for (var k = 0; k < columns.length; k++){
              newIndex.add(columns[k]);
            }
          }
        }
      }
    }
  }
}

/*============================================================================*/

// This custom transformation aims to spot invalid index names, and then
// normalize its name according to name formation rules.

function normalizeIndexName() {
//=============================================================	
	
     function pad(num, size) {
        var s = num+"";
        while (s.length < size) s = "0" + s;
        return s;
     }
   		
//=============================================================	
	
  // Variable to store sequences for index name for
  // each table from the model. This sequence will be used
  // to form the index name, when it does not follow the naming
  // formation rule.
  var tablesIndexSequence;

  tables = model.getTableSet().toArray();
  for (var t = 0; t < tables.length; t++) {
  	tableTmp = tables[t];
     indexes  = tableTmp.getKeys();
     tablesIndexSequence = 0;
     for (var i = 0; i < indexes.length; i++) {
        index = indexes[i];             
        if (!isValidIndexName(index)) {
          index.setName((index.isPK() ? "PK_" : "IDX_") + tableTmp.getName() + "_" + pad(++tablesIndexSequence, 2));
          tableTmp.setDirty(true);
        }
     }
  }
}]]>
		</script>
	</scr>
	<scr id="0386CF20-7A5F-BE9F-E5B6-4CB1004A4F1A" name="TJRS - Normalize index name" object="relational" engine="Oracle Nashorn" type="" var="model" library="TJRS lib" method="normalizeIndexName" purpose="transformation" >
		<script>
			<![CDATA[// Variable used to return custom message
var ruleMessage;
  
// Variables used to return the type of the ruler Error
// or Warning and red/blue  color will be used for result
// if another custom type is returned (Problem in the rule below)
// then result is colored in yellow.
var errType;

/*============================================================================*/

function versaoBiblioteca() {
  var versao = "Versão: 1.0.24.01.2019";
  var titulo = "TJRS - Biblioteca de scripts";

  javax.swing.JOptionPane
     .showMessageDialog
     (null, 
      versao,
      titulo,
      javax.swing.JOptionPane.INFORMATION_MESSAGE
     );
}

/*============================================================================*/

/**
 * Validate the index name, through a ReGex, based on the following
 * document:
 * https://www.tjrs.gov.br/sistemas/redmine/projects/dc34vcqwe4/wiki/Padr%C3%A3o_de_Nome_de_Objetos_de_Banco_de_Dados
 * Parameter
 *   pIndex: a index object
 * Returns
 *   Boolean. True if the index name conforms to index name rule, 
 *            otherwise False.
 */
function isValidIndexName(pIndex) {
   /**
    * Regular expression to match an index name
    * For more information, acess: https://regex101.com/r/aA8hI6/1
    * 
    * Rationale: ^IDX\_.+\_\d{2}$ or /^PK\_.+\_\d{2}$/i
    *   ^ asserts position at start of a line
    *   IDX matches the characters IDX literally (case sensitive)
    *   \_ matches the character _ literally (case sensitive)
    *   .+ matches any character (except for line terminators)
    *   + Quantifier — Matches between one and unlimited times, as many times as possible, giving back as needed (greedy)
    *   \_ matches the character _ literally (case sensitive)
    *   \d{2} matches a digit (equal to [0-9])
    *   {2} Quantifier — Matches exactly 2 times
    *   $ asserts position at the end of a line
    */
   regexp = (pIndex.isPK() ? /^PK\_.+\_\d{2}$/i : /^IDX\_.+\_\d{2}$/i);
   
   return regexp.test(pIndex.getName());
}

/*============================================================================*/

/**
 * Pad zeros to a given number
 * 
 * Parameters
 *   num: a number to be paded
 *   size: leftmost zeroes to pad
 * Returns
 *   The number with leftmost zeroes
 */
function pad(num, size) {
   var s = num+"";
   while (s.length < size) s = "0" + s;
   return s;
}

/*============================================================================*/

/**
 * This Design rule aims to spot indexes, which as not compliance
 * with name formation rule.
 * 
 * Parameters
 *    table: a given table object
 * Returns
 *    Boolean. True if the design rule is satisfied,
 *             otherwise False.
 */
function indexWithInvalidName(table) {

  // Stores the result of this custom
  // design rule.
  result  = true;  

  // Stores the list of table's keys, 
  // and then iterate over it.
  indexes = table.getKeys();
  
  for (var i = 0; i < indexes.length; i++) {
    index = indexes[i];
    if (!index.isPK()){
    	 if (!isValidIndexName(index)) {
    	   ruleMessage  = "The index " + index.getName();
    	   ruleMessage += " has an invalid name. It must be IDX_"
    	   ruleMessage += table.getName() + "_NN, where NN is a two digits number.";
    	   errType = "Error";
    	   return false;
    	 }
    }
  }
  return result;
}

/*============================================================================*/

/**
 * This Design rule aims to spot foreign key constraints which
 * have no index to support it.
 * 
 * Parameters
 *   table: a given table object
 * Returns
 *    Boolean. True if the design rule is satisfied,
 *             otherwise False.
 */
function FKWithOutIndex(table) {

  // Stores the list of table's keys, 
  // and then iterate over it.
  indexes       = table.getKeys();

  // Stores the result of this custom
  // design rule.
  result        = true;

  // Helps to control message text composition.
  newIndexCount = 0;

  // The error message template.
  ruleMessage   = "There is no index for constraint(s):";
	
  // Return an index reference for a given table and
  // column set
  function getIndex(tab,cols){
    keys = tab.getKeys();
    for (var i = 0; i < keys.length; i++) {
      indexTmp = keys[i];
      if(!(indexTmp.isPK() || indexTmp.isUnique()) && !indexTmp.isFK() && indexTmp.isIndexForColumns(cols)){
        return indexTmp
      }
    }
    return null;
  }
  
  for (var i = 0; i < indexes.length; i++) {
    index = indexes[i];
    if (index.isFK()){
      columns = index.getColumns();
      if (columns.length>0){
        newIndex = getIndex(table,columns);
        if (newIndex==null){
          separator    = (++newIndexCount > 1) ? "; " : " ";          
          ruleMessage += separator + index.getName();
          errType      = "Error";
          result       = false;
        }
      }
    }
  }
  return result;
}

/*============================================================================*/

/**
 * This custom transformation aims to spot FKs with have no index
 * and then create the index definition to support it.
 */
function createIndexOnFK() {
  function getIndex(tab,cols){
   keys = tab.getKeys();
   for (var i = 0; i < keys.length; i++) {
    indexTmp = keys[i];
    if(!(indexTmp.isPK() || indexTmp.isUnique()) && !indexTmp.isFK() && indexTmp.isIndexForColumns(cols)){
       return indexTmp
     }
   }
   return null;
  }
  
  // Variable to store sequences for index name for
  // each table from the model. This sequence will be used
  // to form the index name, when it does not follow the naming
  // formation rule.
  var tablesIndexSequence;
  
  tables = model.getTableSet().toArray();
  for (var t = 0; t<tables.length;t++){
    table = tables[t];
    tablesIndexSequence = 0;
    indexes = table.getKeys();
    for (var i = 0; i < indexes.length; i++) {
       index = indexes[i];
       if(index.isFK()){
        columns = index.getColumns();
        if(columns.length>0){
          newIndex = getIndex(table,columns);       
          if(newIndex==null){         
            newIndex = table.createIndex();
            newIndex.setName('IDX_' + table.getName() + '_' + pad(++tablesIndexSequence, 2));
            table.setDirty(true);
            for (var k = 0; k < columns.length; k++){
              newIndex.add(columns[k]);
            }
          }
        }
      }
    }
  }
}

/*============================================================================*/

/**
 * This custom transformation aims to spot invalid index names, and then
 * normalize its name according to name formation rules.
 * 
 * See https://www.tjrs.gov.br/sistemas/redmine/projects/dc34vcqwe4/wiki/Padr%C3%A3o_de_Nome_de_Objetos_de_Banco_de_Dados
 */
function normalizeIndexName() {
  // Variable to store sequences for index name for
  // each table from the model. This sequence will be used
  // to form the index name, when it does not follow the naming
  // formation rule.
  var tablesIndexSequence;

  // Search for the highest index sequence by
  // transversing pIndexes array;
  function initIndexSequence(pIndexes, pTable) {

  	indexSequenceTmp = 1;
  	indexSequenceRet = 1;
  	colision         = false;
  	  	
  	for (var seq = 0; seq < pIndexes.length; seq++) {
  		indexTmp = pIndexes[seq];

          // Discard PK index in search of highest index
          // sequence.
  		if (!indexTmp.isPK()) {
  		   indexNameTmp = "IDX_" + pTable.getName() + "_" + pad(indexSequenceTmp++, 2);
  		   indexTmp     = null;
  		   indexTmp     = pTable.getIndexByName(indexNameTmp);

  		   if (indexTmp != null) {
  			 indexSequenceRet = indexSequenceTmp;
  			 colision = true;
  		   }
  	     }
  	}

  	return (colision ? indexSequenceRet : 1);
  }

  tables = model.getTableSet().toArray();
  for (var t = 0; t < tables.length; t++) {
  	tableTmp = tables[t];
     indexes  = tableTmp.getKeys();
     tablesIndexSequence = initIndexSequence(indexes, tableTmp);
     for (var i = 0; i < indexes.length; i++) {
        index = indexes[i];             
        if (!isValidIndexName(index)) {
        	// Set the new index name based on naming rule.
        	// For PK index, the sequence will be discarded.
          //index.setName((index.isPK() ? "PK_" : "IDX_") + tableTmp.getName() + "_" + pad(tablesIndexSequence++, 2));

          index.setName((index.isPK() ? "PK_" : "IDX_") + tableTmp.getName() + (index.isPK() ? "" : "_" + pad(tablesIndexSequence++, 2)));
          
          tableTmp.setDirty(true);
        }
     }
  }
}

/*============================================================================*/

/**
 * This Design rule aims to spot table which
 * have no primary key.
 * 
 * Parameters
 *   table: a given table object
 * Returns
 *    Boolean. True if the design rule is satisfied,
 *             otherwise False.
 */
function tableWithOutPK(table) {

  // Stores the result of this custom
  // design rule.
  result        = true;

  // Try to retrieve the table's PK.
  pk = table.getPK();

  if (pk == null) {
  	ruleMessage = "there is no primary key for this table.";
     errType     = "Error";
     result      = false;
  }

  return result;
}

/*============================================================================*/

/**
 * This Design rule aims to spot table which
 * have no expected volume registered in the model.
 * 
 * Parameters
 *   table: a given table object
 * Returns
 *    Boolean. True if the design rule is satisfied,
 *             otherwise False.
 */

function tableWithOutVolumetry(table) {

  // Stores the result of this custom
  // design rule.
  result        = true;	

  // Get the expected amount of rows
  expectedVolume = table.getExpectedVolumes();

  if (expectedVolume == 0 || expectedVolume == null) {
  	ruleMessage = "the table property 'Expected' cannot be 0 or null. Check table's Volume Properties.";
     errType     = "Error";
     result      = false;
  }

  return result;  
}

/*============================================================================*/

/**
 * This Design rule aims to spot table which
 * have no expected volume property registered in the model.
 * 
 * Parameters
 *   table: a given table object
 * Returns
 *    Boolean. True if the design rule is satisfied,
 *             otherwise False.
 */

function tableWithOutVolumetry(table) {

  // Stores the result of this custom
  // design rule.
  result        = true;	

  // Get the expected amount of rows
  expectedVolume = table.getExpectedVolumes();

  if (expectedVolume == 0 || expectedVolume == null) {
  	ruleMessage = "the table property 'Expected' cannot be 0 or null. Check table's Volume Properties.";
     errType     = "Error";
     result      = false;
  }

  return result;  
}

/*============================================================================*/

/**
 * This Design rule aims to spot table which
 * have no compression property assigned to it.
 * 
 * Parameters
 *   table: a given table object
 * Returns
 *    Boolean. True if the design rule is satisfied,
 *             otherwise False.
 */

function tableWithOutDataCompression(table) {

  // Stores the result of this custom
  // design rule.
  result        = true;	

  // Get the expected amount of rows
  expectedVolume = table.getExpectedVolumes();

  if (expectedVolume == 0 || expectedVolume == null) {
  	ruleMessage = "the table property 'Expected' cannot be 0 or null. Check table's Volume Properties.";
     errType     = "Error";
     result      = false;
  }

  return result;  
}

/**
 * The goal of this custom transformation script is to modify SQL command line
 * session to set stop running the script on failure behavior and force
 * the current schema to avoid to create the object in the wrong schema.
 * 
 * This function is being used by DDL Generator.
 */
function generateSQLConfiguration() {
	var cfgDDL;

	cfgDDL  = "\nPROMPT Configuracao do ambiente de execucao do SQL\n";
	cfgDDL += "WHENEVER SQLERROR EXIT FAILURE;\n";
	cfgDDL += "SET SCAN OFF;\n";
	
     // Assumes that the first element from the array of users is
     // the correct user that represents the main model's schema.
     // There is opened at My Oracle Support, SR 3-19213495941, asking how to
     // get this information from Relational Model, Schemas rather than from
     // from Physcal Model.
     users = model.getStorageDesign().getUserSchemaSet().toArray();
     user  = users[0];

     cfgDDL += "ALTER SESSION SET CURRENT_SCHEMA=" + user.getName() + "\n\n";
	
	// Add the configuration at the begining of DDL script
	ddlStatementsList.add(new java.lang.String(cfgDDL));
}

function getTableVolumetry(pTable) {
	
	var table = model.getTableSet().getByName(pTable.getName());
	var retVolumetry = 0;
	
	if (table != null) {
		retVolumetry = table.getExpectedVolumes();
	}
	
	return retVolumetry;
}

/**
 * The goal of this custom transformation script is to adjust
 * tables' storage parameters according to cient's standards.
 * For example, the right tablespace will be defined based on "expected rows"
 * property, stored in tables' metadata. There are a set of other properties that
 * will be adjusted as client's standards.
 */
function normalizeStorageProperties() {

	// Constants for properties to be updated in
	// the model.
	var DATA_COMPRESSION_YES  = "YES";
	var DATA_COMPRESSION_HIGH = "HIGH";
	var COMPRESSION_OLTP      = "OLTP";
	var LOB_STORAGE_TYPE_SEC  = "SECUREFILE";
	var LOB_DUP_TYPE_DEDUP    = "DEDUPLICATE";
	var LOB_CACHE_READS       = "CACHE READS";
	var LOB_CHUNK_ZERO        = 0;
	var LOB_VERSION_RETENTION = "RETENTION";

	// Table's Tablespace per expected rows
	var TABLE_TABLESPACE_SMALL  = "HP_1M_01D";
	var TABLE_TABLESPACE_MEDIUM = "HP_16M_01D";
	var TABLE_TABLESPACE_LARGE  = "HP_256M_01D";
	
	// Index's Tablespace per table expected rows
	var INDEX_TABLESPACE_SMALL  = "HP_1M_01X";
	var INDEX_TABLESPACE_MEDIUM = "HP_16M_01X";
	var INDEX_TABLESPACE_LARGE  = "HP_256M_01X";
	
	// Lob's Tablespace per table expected rows
	var LOB_TABLESPACE_SMALL  = "OA_1M_32K_01L";
	var LOB_TABLESPACE_MEDIUM = "OA_16M_32K_01L";
	var LOB_TABLESPACE_LARGE  = "OA_256M_32K_01L";	

	// Retrieve and process a set of tables from the Physical Model
	var tables = model.getStorageDesign().getTableProxySet().toArray();
	
	for (var i=0; i < tables.length; i++) {
		table = tables[i]
	
		// Adjust table compression and compression type
		if (table.getDataSegmentCompression() != DATA_COMPRESSION_YES) {
			table.setDataSegmentCompression(DATA_COMPRESSION_YES);
			table.setDirty(true);
		}
	
		if (table.getCompressionType() != COMPRESSION_OLTP) {
			table.setCompressionType(true);
			table.setDirty(true);
		}
		
		// Adjust table's tablespace based on volumetry stored
		// in table's Relational Model section.
		tableVolumetry = getTableVolumetry(table);
		if (tableVolumetry != null) {
			if (tableVolumetry >= 0 && tableVolumetry <= 100000) {
				tableSpace = model.getStorageDesign().getTableSpaceSet().getByName(TABLE_TABLESPACE_SMALL);
				table.setTableSpace(tableSpace);
			} else if (tableVolumetry >= 100001 && tableVolumetry <= 1000000) {
				tableSpace = model.getStorageDesign().getTableSpaceSet().getByName(TABLE_TABLESPACE_MEDIUM);
				table.setTableSpace(tableSpace);
			} else if (tableVolumetry > 1000000) {
				tableSpace = model.getStorageDesign().getTableSpaceSet().getByName(TABLE_TABLESPACE_LARGE);
				table.setTableSpace(tableSpace);
			}
		}

	     // Adjust table indexes' tablespace based on volumetry stored
		// in table's Relational Model section.
	     tableIndexes = table.getIndexes().toArray();
	     for (var x=0; x < tableIndexes.length; x++) {
	     	tableIndex = tableIndexes[x];
	     	if (tableVolumetry != null) {
	     		if (tableVolumetry >= 0 && tableVolumetry <= 100000) {
	     			tableSpace = model.getStorageDesign().getTableSpaceSet().getByName(INDEX_TABLESPACE_SMALL);
	     			tableIndex.setTableSpace(tableSpace);
	     		} else if (tableVolumetry >= 100001 && tableVolumetry <= 1000000) {
	     			tableSpace = model.getStorageDesign().getTableSpaceSet().getByName(INDEX_TABLESPACE_MEDIUM);
	     			tableIndex.setTableSpace(tableSpace);
	     		} else if (tableVolumetry > 1000000) {
	     			tableSpace = model.getStorageDesign().getTableSpaceSet().getByName(INDEX_TABLESPACE_LARGE);
	     			tableIndex.setTableSpace(tableSpace);
	     		}

	     		tableIndex.setDirty(true);
	     	}
	     }
	     
		// Adjust table's Lob Storage ans Tablespace, just in case it exists for the underlying table,
		// as follows:
		tableLobStorages = table.getLobStorages().toArray();
		for (var k=0; k < tableLobStorages.length; k++) {
			tableLobStorage = tableLobStorages[k];
			
			tableLobStorage.setLobStorageType(LOB_STORAGE_TYPE_SEC);
			tableLobStorage.setCompression(DATA_COMPRESSION_YES);
			tableLobStorage.setCompressionType(DATA_COMPRESSION_HIGH);
			tableLobStorage.setDuplication(LOB_DUP_TYPE_DEDUP);
			tableLobStorage.setCache(LOB_CACHE_READS);
			tableLobStorage.setChunk(LOB_CHUNK_ZERO);
			tableLobStorage.setOldVersions(LOB_VERSION_RETENTION);

	     	if (tableVolumetry != null) {
	     		if (tableVolumetry >= 0 && tableVolumetry <= 100000) {
	     			tableSpace = model.getStorageDesign().getTableSpaceSet().getByName(LOB_TABLESPACE_SMALL);
	     			tableLobStorage.setTableSpace(tableSpace);
	     		} else if (tableVolumetry >= 100001 && tableVolumetry <= 1000000) {
	     			tableSpace = model.getStorageDesign().getTableSpaceSet().getByName(LOB_TABLESPACE_MEDIUM);
	     			tableLobStorage.setTableSpace(tableSpace);
	     		} else if (tableVolumetry > 1000000) {
	     			tableSpace = model.getStorageDesign().getTableSpaceSet().getByName(LOB_TABLESPACE_LARGE);
	     			tableLobStorage.setTableSpace(tableSpace);
	     		}
	     	}
	     	
			table.setDirty(true);
		}
	}
}]]>
		</script>
	</scr>
	<scr id="0B39A5FF-E071-7136-44C6-F393F9860AE0" name="TJRS - Adjust table storage properties" object="relational" engine="Oracle Nashorn" type="" var="model" library="TJRS lib" method="normalizeStorageProperties" purpose="transformation" >
		<script>
			<![CDATA[// Variable used to return custom message
var ruleMessage;
  
// Variables used to return the type of the ruler Error
// or Warning and red/blue  color will be used for result
// if another custom type is returned (Problem in the rule below)
// then result is colored in yellow.
var errType;

/*============================================================================*/

function versaoBiblioteca() {
  var versao = "Versão: 1.0.15.02.2019";
  var titulo = "TJRS - Biblioteca de scripts";

  javax.swing.JOptionPane
     .showMessageDialog
     (null, 
      versao,
      titulo,
      javax.swing.JOptionPane.INFORMATION_MESSAGE
     );
}

/*============================================================================*/

/**
 * Validate the index name, through a ReGex, based on the following
 * document:
 * https://www.tjrs.gov.br/sistemas/redmine/projects/dc34vcqwe4/wiki/Padr%C3%A3o_de_Nome_de_Objetos_de_Banco_de_Dados
 * Parameter
 *   pIndex: a index object
 * Returns
 *   Boolean. True if the index name conforms to index name rule, 
 *            otherwise False.
 */
function isValidIndexName(pIndex) {
   /**
    * Regular expression to match an index name
    * For more information, acess: https://regex101.com/r/aA8hI6/1
    * 
    * Rationale: ^IDX\_.+\_\d{2}$ or /^PK\_.+\_\d{2}$/i
    *   ^ asserts position at start of a line
    *   IDX matches the characters IDX literally (case sensitive)
    *   \_ matches the character _ literally (case sensitive)
    *   .+ matches any character (except for line terminators)
    *   + Quantifier — Matches between one and unlimited times, as many times as possible, giving back as needed (greedy)
    *   \_ matches the character _ literally (case sensitive)
    *   \d{2} matches a digit (equal to [0-9])
    *   {2} Quantifier — Matches exactly 2 times
    *   $ asserts position at the end of a line
    */
   regexp = (pIndex.isPK() ? /^PK\_.+\_\d{2}$/i : /^IDX\_.+\_\d{2}$/i);
   
   return regexp.test(pIndex.getName());
}

/*============================================================================*/

/**
 * Pad zeros to a given number
 * 
 * Parameters
 *   num: a number to be paded
 *   size: leftmost zeroes to pad
 * Returns
 *   The number with leftmost zeroes
 */
function pad(num, size) {
   var s = num+"";
   while (s.length < size) s = "0" + s;
   return s;
}

/*============================================================================*/

/**
 * This Design rule aims to spot indexes, which as not compliance
 * with name formation rule.
 * 
 * Parameters
 *    table: a given table object
 * Returns
 *    Boolean. True if the design rule is satisfied,
 *             otherwise False.
 */
function indexWithInvalidName(table) {

  // Stores the result of this custom
  // design rule.
  result  = true;  

  // Stores the list of table's keys, 
  // and then iterate over it.
  indexes = table.getKeys();
  
  for (var i = 0; i < indexes.length; i++) {
    index = indexes[i];
    if (!index.isPK()){
    	 if (!isValidIndexName(index)) {
    	   ruleMessage  = "The index " + index.getName();
    	   ruleMessage += " has an invalid name. It must be IDX_"
    	   ruleMessage += table.getName() + "_NN, where NN is a two digits number.";
    	   errType = "Error";
    	   return false;
    	 }
    }
  }
  return result;
}

/*============================================================================*/

/**
 * This Design rule aims to spot foreign key constraints which
 * have no index to support it.
 * 
 * Parameters
 *   table: a given table object
 * Returns
 *    Boolean. True if the design rule is satisfied,
 *             otherwise False.
 */
function FKWithOutIndex(table) {

  // Stores the list of table's keys, 
  // and then iterate over it.
  indexes       = table.getKeys();

  // Stores the result of this custom
  // design rule.
  result        = true;

  // Helps to control message text composition.
  newIndexCount = 0;

  // The error message template.
  ruleMessage   = "There is no index for constraint(s):";
	
  // Return an index reference for a given table and
  // column set
  function getIndex(tab,cols){
    keys = tab.getKeys();
    for (var i = 0; i < keys.length; i++) {
      indexTmp = keys[i];
      if(!(indexTmp.isPK() || indexTmp.isUnique()) && !indexTmp.isFK() && indexTmp.isIndexForColumns(cols)){
        return indexTmp
      }
    }
    return null;
  }
  
  for (var i = 0; i < indexes.length; i++) {
    index = indexes[i];
    if (index.isFK()){
      columns = index.getColumns();
      if (columns.length>0){
        newIndex = getIndex(table,columns);
        if (newIndex==null){
          separator    = (++newIndexCount > 1) ? "; " : " ";          
          ruleMessage += separator + index.getName();
          errType      = "Error";
          result       = false;
        }
      }
    }
  }
  return result;
}

/*============================================================================*/

/**
 * This custom transformation aims to spot FKs with have no index
 * and then create the index definition to support it.
 */
function createIndexOnFK() {
  function getIndex(tab,cols){
   keys = tab.getKeys();
   for (var i = 0; i < keys.length; i++) {
    indexTmp = keys[i];
    if(!(indexTmp.isPK() || indexTmp.isUnique()) && !indexTmp.isFK() && indexTmp.isIndexForColumns(cols)){
       return indexTmp
     }
   }
   return null;
  }
  
  // Variable to store sequences for index name for
  // each table from the model. This sequence will be used
  // to form the index name, when it does not follow the naming
  // formation rule.
  var tablesIndexSequence;
  
  tables = model.getTableSet().toArray();
  for (var t = 0; t<tables.length;t++){
    table = tables[t];
    tablesIndexSequence = 0;
    indexes = table.getKeys();
    for (var i = 0; i < indexes.length; i++) {
       index = indexes[i];
       if(index.isFK()){
        columns = index.getColumns();
        if(columns.length>0){
          newIndex = getIndex(table,columns);       
          if(newIndex==null){         
            newIndex = table.createIndex();
            newIndex.setName('IDX_' + table.getName() + '_' + pad(++tablesIndexSequence, 2));
            table.setDirty(true);
            for (var k = 0; k < columns.length; k++){
              newIndex.add(columns[k]);
            }
          }
        }
      }
    }
  }
}

/*============================================================================*/

/**
 * This custom transformation aims to spot invalid index names, and then
 * normalize its name according to name formation rules.
 * 
 * See https://www.tjrs.gov.br/sistemas/redmine/projects/dc34vcqwe4/wiki/Padr%C3%A3o_de_Nome_de_Objetos_de_Banco_de_Dados
 */
function normalizeIndexName() {
  // Variable to store sequences for index name for
  // each table from the model. This sequence will be used
  // to form the index name, when it does not follow the naming
  // formation rule.
  var tablesIndexSequence;

  // Search for the highest index sequence by
  // transversing pIndexes array;
  function initIndexSequence(pIndexes, pTable) {

  	indexSequenceTmp = 1;
  	indexSequenceRet = 1;
  	colision         = false;
  	  	
  	for (var seq = 0; seq < pIndexes.length; seq++) {
  		indexTmp = pIndexes[seq];

          // Discard PK index in search of highest index
          // sequence.
  		if (!indexTmp.isPK()) {
  		   indexNameTmp = "IDX_" + pTable.getName() + "_" + pad(indexSequenceTmp++, 2);
  		   indexTmp     = null;
  		   indexTmp     = pTable.getIndexByName(indexNameTmp);

  		   if (indexTmp != null) {
  			 indexSequenceRet = indexSequenceTmp;
  			 colision = true;
  		   }
  	     }
  	}

  	return (colision ? indexSequenceRet : 1);
  }

  tables = model.getTableSet().toArray();
  for (var t = 0; t < tables.length; t++) {
  	tableTmp = tables[t];
     indexes  = tableTmp.getKeys();
     tablesIndexSequence = initIndexSequence(indexes, tableTmp);
     for (var i = 0; i < indexes.length; i++) {
        index = indexes[i];             
        if (!isValidIndexName(index)) {
        	// Set the new index name based on naming rule.
        	// For PK index, the sequence will be discarded.
          //index.setName((index.isPK() ? "PK_" : "IDX_") + tableTmp.getName() + "_" + pad(tablesIndexSequence++, 2));

          index.setName((index.isPK() ? "PK_" : "IDX_") + tableTmp.getName() + (index.isPK() ? "" : "_" + pad(tablesIndexSequence++, 2)));
          
          tableTmp.setDirty(true);
        }
     }
  }
}

/*============================================================================*/

/**
 * This Design rule aims to spot table which
 * have no primary key.
 * 
 * Parameters
 *   table: a given table object
 * Returns
 *    Boolean. True if the design rule is satisfied,
 *             otherwise False.
 */
function tableWithOutPK(table) {

  // Stores the result of this custom
  // design rule.
  result        = true;

  // Try to retrieve the table's PK.
  pk = table.getPK();

  if (pk == null) {
  	ruleMessage = "there is no primary key for this table.";
     errType     = "Error";
     result      = false;
  }

  return result;
}

/*============================================================================*/

/**
 * This Design rule aims to spot table which
 * have no expected volume registered in the model.
 * 
 * Parameters
 *   table: a given table object
 * Returns
 *    Boolean. True if the design rule is satisfied,
 *             otherwise False.
 */

function tableWithOutVolumetry(table) {

  // Stores the result of this custom
  // design rule.
  result        = true;	

  // Get the expected amount of rows
  expectedVolume = table.getExpectedVolumes();

  if (expectedVolume == 0 || expectedVolume == null) {
  	ruleMessage = "the table property 'Expected' cannot be 0 or null. Check table's Volume Properties.";
     errType     = "Error";
     result      = false;
  }

  return result;  
}

/*============================================================================*/

/**
 * This Design rule aims to spot table which
 * have no expected volume property registered in the model.
 * 
 * Parameters
 *   table: a given table object
 * Returns
 *    Boolean. True if the design rule is satisfied,
 *             otherwise False.
 */

function tableWithOutVolumetry(table) {

  // Stores the result of this custom
  // design rule.
  result        = true;	

  // Get the expected amount of rows
  expectedVolume = table.getExpectedVolumes();

  if (expectedVolume == 0 || expectedVolume == null) {
  	ruleMessage = "the table property 'Expected' cannot be 0 or null. Check table's Volume Properties.";
     errType     = "Error";
     result      = false;
  }

  return result;  
}

/*============================================================================*/

/**
 * This Design rule aims to spot table which
 * have no compression property assigned to it.
 * 
 * Parameters
 *   table: a given table object
 * Returns
 *    Boolean. True if the design rule is satisfied,
 *             otherwise False.
 */
function tableWithOutDataCompression(table) {

  // Stores the result of this custom
  // design rule.
  result        = true;	

  // Get the expected amount of rows
  expectedVolume = table.getExpectedVolumes();

  if (expectedVolume == 0 || expectedVolume == null) {
  	ruleMessage = "the table property 'Expected' cannot be 0 or null. Check table's Volume Properties.";
     errType     = "Error";
     result      = false;
  }

  return result;  
}

/**
 * The goal of this custom transformation script is to modify SQL command line
 * session to set stop running the script on failure behavior and force
 * the current schema to avoid to create the object in the wrong schema.
 * 
 * This function is being used by DDL Generator.
 */
function generateSQLConfiguration() {
	var cfgDDL;

	cfgDDL  = "\nPROMPT Configuracao do ambiente de execucao do SQL\n";
	cfgDDL += "WHENEVER SQLERROR EXIT FAILURE;\n";
	cfgDDL += "SET SCAN OFF;\n";
	
     // Assumes that the first element from the array of users is
     // the correct user that represents the main model's schema.
     // There is opened at My Oracle Support, SR 3-19213495941, asking how to
     // get this information from Relational Model, Schemas rather than from
     // from Physcal Model.
     users = model.getStorageDesign().getUserSchemaSet().toArray();
     user  = users[0];

     cfgDDL += "ALTER SESSION SET CURRENT_SCHEMA=" + user.getName() + "\n\n";
	
	// Add the configuration at the begining of DDL script
	ddlStatementsList.add(new java.lang.String(cfgDDL));
}

/*============================================================================*/

function getTableVolumetry(pTable) {
	
	var table = model.getTableSet().getByName(pTable.getName());
	var retVolumetry = 0;
	
	if (table != null) {
		retVolumetry = table.getExpectedVolumes();
	}
	
	return retVolumetry;
}

/*============================================================================*/

/**
 * The goal of this custom transformation script is to adjust
 * tables' storage parameters according to cient's standards.
 * For example, the right tablespace will be defined based on "expected rows"
 * property, stored in tables' metadata. There are a set of other properties that
 * will be adjusted as client's standards.
 */
function normalizeStorageProperties() {

	// Constants for properties to be updated in
	// the model.
	var DATA_COMPRESSION_YES  = "YES";
	var DATA_COMPRESSION_HIGH = "HIGH";
	var COMPRESSION_OLTP      = "OLTP";
	var LOB_STORAGE_TYPE_SEC  = "SECUREFILE";
	var LOB_DUP_TYPE_DEDUP    = "DEDUPLICATE";
	var LOB_CACHE_READS       = "CACHE READS";
	var LOB_CHUNK_ZERO        = 0;
	var LOB_VERSION_RETENTION = "RETENTION";

	// Table's Tablespace per expected rows
	var TABLE_TABLESPACE_SMALL  = "HP_1M_01D";
	var TABLE_TABLESPACE_MEDIUM = "HP_16M_01D";
	var TABLE_TABLESPACE_LARGE  = "HP_256M_01D";
	
	// Index's Tablespace per table expected rows
	var INDEX_TABLESPACE_SMALL  = "HP_1M_01X";
	var INDEX_TABLESPACE_MEDIUM = "HP_16M_01X";
	var INDEX_TABLESPACE_LARGE  = "HP_256M_01X";
	
	// Lob's Tablespace per table expected rows
	var LOB_TABLESPACE_SMALL  = "OA_1M_32K_01L";
	var LOB_TABLESPACE_MEDIUM = "OA_16M_32K_01L";
	var LOB_TABLESPACE_LARGE  = "OA_256M_32K_01L";

	// Volumetry ranges
	var START_RANGE_SMALL  = 1;
	var END_RANGE_SMALL    = 100000;
	var START_RANGE_MEDIUM = 100001;
	var END_RANGE_MEDIUM   = 1000000;
	var START_RANGE_LARGE  = 1000001;

	// Retrieve and process a set of tables from the Physical Model
	var tables = model.getStorageDesign().getTableProxySet().toArray();
	
	for (var i=0; i < tables.length; i++) {
		table = tables[i]
	
		// Adjust table compression and compression type
		if (table.getDataSegmentCompression() != DATA_COMPRESSION_YES) {
			table.setDataSegmentCompression(DATA_COMPRESSION_YES);
			table.setDirty(true);
		}
	
		if (table.getCompressionType() != COMPRESSION_OLTP) {
			table.setCompressionType(COMPRESSION_OLTP);
			table.setDirty(true);
		}
		
		// Adjust table's tablespace based on volumetry stored
		// in table's Relational Model section.
		tableVolumetry = getTableVolumetry(table);
		if (tableVolumetry != null) {
			if (tableVolumetry >= START_RANGE_SMALL && tableVolumetry <= END_RANGE_SMALL) {
				tableSpace = model.getStorageDesign().getTableSpaceSet().getByName(TABLE_TABLESPACE_SMALL);
				table.setTableSpace(tableSpace);
			} else if (tableVolumetry >= START_RANGE_MEDIUM && tableVolumetry <= END_RANGE_MEDIUM) {
				tableSpace = model.getStorageDesign().getTableSpaceSet().getByName(TABLE_TABLESPACE_MEDIUM);
				table.setTableSpace(tableSpace);
			} else if (tableVolumetry >= START_RANGE_LARGE) {
				tableSpace = model.getStorageDesign().getTableSpaceSet().getByName(TABLE_TABLESPACE_LARGE);
				table.setTableSpace(tableSpace);
			}
		}

	     // Adjust table indexes' tablespace based on volumetry stored
		// in table's Relational Model section.
	     tableIndexes = table.getIndexes().toArray();
	     for (var x=0; x < tableIndexes.length; x++) {
	     	tableIndex = tableIndexes[x];
	     	if (tableVolumetry != null) {
	     		if (tableVolumetry >= START_RANGE_SMALL && tableVolumetry <= END_RANGE_SMALL) {
	     			tableSpace = model.getStorageDesign().getTableSpaceSet().getByName(INDEX_TABLESPACE_SMALL);
	     			tableIndex.setTableSpace(tableSpace);
	     		} else if (tableVolumetry >= START_RANGE_MEDIUM && tableVolumetry <= END_RANGE_MEDIUM) {
	     			tableSpace = model.getStorageDesign().getTableSpaceSet().getByName(INDEX_TABLESPACE_MEDIUM);
	     			tableIndex.setTableSpace(tableSpace);
	     		} else if (tableVolumetry >= START_RANGE_LARGE) {
	     			tableSpace = model.getStorageDesign().getTableSpaceSet().getByName(INDEX_TABLESPACE_LARGE);
	     			tableIndex.setTableSpace(tableSpace);
	     		}

	     		tableIndex.setDirty(true);
	     	}
	     }
	     
		// Adjust table's Lob Storage ans Tablespace, just in case it exists for the underlying table,
		// as follows:
		tableLobStorages = table.getLobStorages().toArray();
		for (var k=0; k < tableLobStorages.length; k++) {
			tableLobStorage = tableLobStorages[k];
			
			tableLobStorage.setLobStorageType(LOB_STORAGE_TYPE_SEC);
			tableLobStorage.setCompression(DATA_COMPRESSION_YES);
			tableLobStorage.setCompressionType(DATA_COMPRESSION_HIGH);
			tableLobStorage.setDuplication(LOB_DUP_TYPE_DEDUP);
			tableLobStorage.setCache(LOB_CACHE_READS);
			tableLobStorage.setChunk(LOB_CHUNK_ZERO);
			tableLobStorage.setOldVersions(LOB_VERSION_RETENTION);

	     	if (tableVolumetry != null) {
	     		if (tableVolumetry >= START_RANGE_SMALL && tableVolumetry <= END_RANGE_SMALL) {
	     			tableSpace = model.getStorageDesign().getTableSpaceSet().getByName(LOB_TABLESPACE_SMALL);
	     			tableLobStorage.setTableSpace(tableSpace);
	     		} else if (tableVolumetry >= START_RANGE_MEDIUM && tableVolumetry <= END_RANGE_MEDIUM) {
	     			tableSpace = model.getStorageDesign().getTableSpaceSet().getByName(LOB_TABLESPACE_MEDIUM);
	     			tableLobStorage.setTableSpace(tableSpace);
	     		} else if (tableVolumetry >= START_RANGE_LARGE) {
	     			tableSpace = model.getStorageDesign().getTableSpaceSet().getByName(LOB_TABLESPACE_LARGE);
	     			tableLobStorage.setTableSpace(tableSpace);
	     		}
	     	}
	     	
			table.setDirty(true);
		}
	}
}

/*============================================================================*/

/**
 * This Design rule aims to spot table which
 * wrong tablespace assingment, based on table's "Volume Properties",
 * "Expected" property.
 * 
 * Parameters
 *   table: a given table object
 * Returns
 *    Boolean. True if the design rule is satisfied,
 *             otherwise False.
 */
function validateTableTablespaceUsage(table) {
	// Table's Tablespace per expected rows
	var TABLE_TABLESPACE_SMALL  = "HP_1M_01D";
	var TABLE_TABLESPACE_MEDIUM = "HP_16M_01D";
	var TABLE_TABLESPACE_LARGE  = "HP_256M_01D";
	
	// Index's Tablespace per table expected rows
	var INDEX_TABLESPACE_SMALL  = "HP_1M_01X";
	var INDEX_TABLESPACE_MEDIUM = "HP_16M_01X";
	var INDEX_TABLESPACE_LARGE  = "HP_256M_01X";
	
	// Lob's Tablespace per table expected rows
	var LOB_TABLESPACE_SMALL  = "OA_1M_32K_01L";
	var LOB_TABLESPACE_MEDIUM = "OA_16M_32K_01L";
	var LOB_TABLESPACE_LARGE  = "OA_256M_32K_01L";

	// Volumetry ranges
	var START_RANGE_SMALL  = 1;
	var END_RANGE_SMALL    = 100000;
	var START_RANGE_MEDIUM = 100001;
	var END_RANGE_MEDIUM   = 1000000;
	var START_RANGE_LARGE  = 1000001;

	var result = true;

	// Before move on check table's volumetry property
	if (!tableWithOutVolumetry(table)) {
		return false;
	}

	// Gets the reference to the model
	model = table.getDesignPart();

	// Retrieve from physical model the table storage
	tableStorage = model.getStorageDesign().getStorageObject(table.getObjectID());

	// Gets the tablespace assigned to the table
     tableTablespace = tableStorage.getTableSpace();
     
	// Gets the expected amount of rows 
	tableVolumetry = table.getExpectedVolumes();

     // Validate tablespace being used by the table based on its volumetry
	if (tableVolumetry != null) {
		ruleMessage  = "Invalid tablespace definition. Using "
		if (tableVolumetry >= START_RANGE_SMALL && tableVolumetry <= END_RANGE_SMALL) {
			if (!tableTablespace.getName().equals(TABLE_TABLESPACE_SMALL)) {
				result       = false;
				ruleMessage += tableTablespace;
				ruleMessage += " instead of " + TABLE_TABLESPACE_SMALL;
				errType      = "Error";
			}
		} else if (tableVolumetry >= START_RANGE_MEDIUM && tableVolumetry <= END_RANGE_MEDIUM) {
			if (!tableTablespace.getName().equals(TABLE_TABLESPACE_MEDIUM)) {
				result       = false;
				ruleMessage += tableTablespace;
				ruleMessage += " instead of " + TABLE_TABLESPACE_MEDIUM;
				errType      = "Error";
			}
		} else if (tableVolumetry >= START_RANGE_LARGE) {
			if (!tableTablespace.getName().equals(START_RANGE_LARGE)) {
				result       = false;
				ruleMessage += tableTablespace;
				ruleMessage += " instead of " + TABLE_TABLESPACE_LARGE;
				errType      = "Error";
			}
		}
	}

	return result;
}

/*============================================================================*/

/**
 * This Design rule aims to spot sequences that use the NOCACHE option.
 * NOCACHE must be used it caution and then the review by developer and/or
 * system analyst is needed.
 * 
 * Parameters
 *   table: a given table object
 * Returns
 *    Boolean. True if the design rule is satisfied,
 *             otherwise False.
 */
function sequencesWithNOCACHE(table) {
	var result = true;

	// Gets the reference to the model
	var model = table.getDesignPart();

	// Retrieve from physical model the sequence set
	var sequenceSet = model.getStorageDesign().getStorageObjectSetForType('Sequence');

     // Clear the design rule's content
     ruleMessage        = "";
     
     // Gets the Uder Defined Preferen to control the design rule
     // execution.
     var setting        = model.getAppView().getSettings();
     var validationDone = setting.getUserDefinedPreferenceValue("VALIDATED");

     if (validationDone.equals("false")) {
        //sequencesWithNOCACHE(table);

        // Set the UDF "VALIDATED" to "true" in order to run
        // this design rule once. The reason is that the sequences are
        // retrieved in the first object (table) feteched by the Javascript
        // runtime. Then the remaining table will be dismissed by this design rule once
        // the UDF "VALIDATED" was set to "true" in the first iteration.
        setting.addUserDefinedPreference("VALIDATED","true");

        javax.swing.JOptionPane
          .showMessageDialog
           (null, 
            "Please update the User Defined Preference 'VALIDATED' to 'false'.",
            "Action required",
            javax.swing.JOptionPane.INFORMATION_MESSAGE
           );
     }
     else {
     	return result;
     }
     
	sequenceArray = sequenceSet.toArray();

	for (var i=0; i < sequenceArray.length; i++) {
		sequence = sequenceArray[i];

		if (sequence.getNoCache().equals("YES")) {
			ruleMessage += " sequence " + sequence.getName() + " is defined as NOCACHE. Please, validate it with system analyst;";
			result = false;
		}
	}

	return result;
}]]>
		</script>
	</scr>
	<scr id="669444D9-7E75-EDA0-0194-7529209E22A5" name="Remove table schema" object="relational" engine="Oracle Nashorn" type="" var="model" library="" method="" purpose="transformation" >
		<script>
			<![CDATA[tables = model.getTableSet().toArray();
for (var t = 0; t<tables.length;t++){
 table = tables[t];
 table.setSchemaObject(null);
 table.setDirty(true);
}]]>
		</script>
	</scr>

	<lib id="B310E434-78AE-6AED-EA94-6808B0262483" name="my first library" engine="Oracle Nashorn" methods="checkcomments,NotNullConstr_Name_Length" >
		<script>
			<![CDATA[// variable used to return custom message
var ruleMessage;
// variable used to return the type of the rule Error
// or Warning and red/blue color will be used for result
// if another custom type is returned (Problem in the rule below) 
// then result is colored in yellow
var errType;
var table;
function checkcomments(object){
 result = true;
 ruleMessage="";
 if(table.getCommentInRDBMS().equals("")){
  ruleMessage="no comments in RDBMS defined";
  errType="Problem:";
  result = false;
 }
 if(table.getComment().equals("")){
  if(ruleMessage.equals("")){
   ruleMessage="no comments defined";
  }else{
   ruleMessage= ruleMessage +" , no comments defined";
   }
   // can be changed to Warning    
   errType="Error";
  return false;
 }
 return result;
}
//rule for not null constraint name
function NotNullConstr_Name_Length(column){
 model = column.getDesignPart();
 name = column.getNotNullConstraintName();
 result = true;
 if(name!=null && !"".equals(name)){
	holder = model.getNamingOptionsHolderFor("oracle.dbtools.crest.model.design.constraint.TableLevelConstraint");
	if ((holder.getMaxNameLength() > 0) && (name.length() > holder.getMaxNameLength())) {
		result = false;
	}
 }
 return result
}]]>
		</script>
	</lib>
	<lib id="2518F33A-DE50-9E1D-7216-DD2A0FD6B84C" name="Jruby lib" engine="JSR 223 JRuby Engine" methods="tables_up" >
		<script>
			<![CDATA[def tables_up(model)
tables = model.getTableSet().toArray()
for t in 0..tables.length-1
 table = tables[t]
 name = table.getName().upcase
 table.setName(name)
 columns = table.getElements()
 size = table.getElementsCollection().size()-1
 for i in 0..size
	column = columns[i]
	cname = column.getName().upcase
	column.setName(cname)
 end
 keys = table.getKeys()
 for i in 0..keys.length-1
  key = keys[i]
  kname = key.getName().upcase
  key.setName(kname)
 end
end
return true
end]]>
		</script>
	</lib>
	<lib id="79C2ED6C-9A18-434F-F0FE-838F87B60814" name="TJRS lib" engine="Oracle Nashorn" methods="versaoBiblioteca,indexWithInvalidName,FKWithOutIndex,createIndexOnFK,normalizeIndexName,tableWithOutPK,tableWithOutVolumetry,tableWithOutDataCompression,generateSQLConfiguration,normalizeStorageProperties,validateTableTablespaceUsage,sequencesWithNOCACHE,removeSchemaFromTables" >
		<script>
			<![CDATA[// Variable used to return custom message
var ruleMessage;
  
// Variables used to return the type of the ruler Error
// or Warning and red/blue  color will be used for result
// if another custom type is returned (Problem in the rule below)
// then result is colored in yellow.
var errType;

// Constants declaration
//const INFORMATION_MESSAGE = javax.swing.JOptionPane.INFORMATION_MESSAGE;

/*============================================================================*/

function versaoBiblioteca() {
  var versao = "Versão: 1.2.03.10.2019";
  var titulo = "TJRS - Biblioteca de scripts";

  javax.swing.JOptionPane
     .showMessageDialog
     (null, 
      versao,
      titulo,
      javax.swing.JOptionPane.INFORMATION_MESSAGE
     );
}

/*============================================================================*/

/**
 * This custom transformation aims to clear the property "schema"
 * from tables in relational model.
 */
function removeSchemaFromTables() {
	tables = model.getTableSet().toArray();
	for (var t = 0; t < tables.length; t++) {
		table = tables[t];
		table.setSchemaObject(null);
		table.setDirty(true);
	}
}

/*============================================================================*/

/**
 * Validate the index name, through a ReGex, based on the following
 * document:
 * https://www.tjrs.gov.br/sistemas/redmine/projects/dc34vcqwe4/wiki/Padr%C3%A3o_de_Nome_de_Objetos_de_Banco_de_Dados
 * Parameter
 *   pIndex: a index object
 * Returns
 *   Boolean. True if the index name conforms to index name rule, 
 *            otherwise False.
 */
function isValidIndexName(pIndex) {
   /**
    * Regular expression to match an index name
    * For more information, acess: https://regex101.com/r/aA8hI6/1
    * 
    * Rationale: ^IDX\_.+\_\d{2}$ or /^PK\_.+\_\d{2}$/i
    *   ^ asserts position at start of a line
    *   IDX matches the characters IDX literally (case sensitive)
    *   \_ matches the character _ literally (case sensitive)
    *   .+ matches any character (except for line terminators)
    *   + Quantifier — Matches between one and unlimited times, as many times as possible, giving back as needed (greedy)
    *   \_ matches the character _ literally (case sensitive)
    *   \d{2} matches a digit (equal to [0-9])
    *   {2} Quantifier — Matches exactly 2 times
    *   $ asserts position at the end of a line
    */
   regexp = (pIndex.isPK() ? /^PK\_.+\_\d{2}$/i : /^IDX\_.+\_\d{2}$/i);
   
   return regexp.test(pIndex.getName());
}

/*============================================================================*/

/**
 * Pad zeros to a given number
 * 
 * Parameters
 *   num: a number to be paded
 *   size: leftmost zeroes to pad
 * Returns
 *   The number with leftmost zeroes
 */
function pad(num, size) {
   var s = num+"";
   while (s.length < size) s = "0" + s;
   return s;
}

/*============================================================================*/

/**
 * This Design rule aims to spot indexes, which as not compliance
 * with name formation rule.
 * 
 * Parameters
 *    table: a given table object
 * Returns
 *    Boolean. True if the design rule is satisfied,
 *             otherwise False.
 */
function indexWithInvalidName(table) {

  // Stores the result of this custom
  // design rule.
  result  = true;  

  // Stores the list of table's keys, 
  // and then iterate over it.
  indexes = table.getKeys();
  
  for (var i = 0; i < indexes.length; i++) {
    index = indexes[i];
    if (!index.isPK()){
    	 if (!isValidIndexName(index)) {
    	   ruleMessage  = "The index " + index.getName();
    	   ruleMessage += " has an invalid name. It must be IDX_"
    	   ruleMessage += table.getName() + "_NN, where NN is a two digits number.";
    	   errType = "Error";
    	   return false;
    	 }
    }
  }
  return result;
}

/*============================================================================*/

/**
 * This Design rule aims to spot foreign key constraints which
 * have no index to support it.
 * 
 * Parameters
 *   table: a given table object
 * Returns
 *    Boolean. True if the design rule is satisfied,
 *             otherwise False.
 */
function FKWithOutIndex(table) {

  // Stores the list of table's keys, 
  // and then iterate over it.
  indexes       = table.getKeys();

  // Stores the result of this custom
  // design rule.
  result        = true;

  // Helps to control message text composition.
  newIndexCount = 0;

  // The error message template.
  ruleMessage   = "There is no index for constraint(s):";
	
  // Return an index reference for a given table and
  // column set
  function getIndex(tab,cols){
    keys = tab.getKeys();
    for (var i = 0; i < keys.length; i++) {
      indexTmp = keys[i];
      if(!(indexTmp.isPK() || indexTmp.isUnique()) && !indexTmp.isFK() && indexTmp.isIndexForColumns(cols)){
        return indexTmp
      }
    }
    return null;
  }
  
  for (var i = 0; i < indexes.length; i++) {
    index = indexes[i];
    if (index.isFK()){
      columns = index.getColumns();
      if (columns.length>0){
        newIndex = getIndex(table,columns);
        if (newIndex==null){
          separator    = (++newIndexCount > 1) ? "; " : " ";          
          ruleMessage += separator + index.getName();
          errType      = "Error";
          result       = false;
        }
      }
    }
  }
  return result;
}

/*============================================================================*/

/**
 * This custom transformation aims to spot FKs with have no index
 * and then create the index definition to support it.
 */
function createIndexOnFK() {
  function getIndex(tab,cols){
   keys = tab.getKeys();
   for (var i = 0; i < keys.length; i++) {
    indexTmp = keys[i];
    if(!(indexTmp.isPK() || indexTmp.isUnique()) && !indexTmp.isFK() && indexTmp.isIndexForColumns(cols)){
       return indexTmp
     }
   }
   return null;
  }
  
  // Variable to store sequences for index name for
  // each table from the model. This sequence will be used
  // to form the index name, when it does not follow the naming
  // formation rule.
  var tablesIndexSequence;
  
  tables = model.getTableSet().toArray();
  for (var t = 0; t<tables.length;t++){
    table = tables[t];
    tablesIndexSequence = 0;
    indexes = table.getKeys();
    for (var i = 0; i < indexes.length; i++) {
       index = indexes[i];
       if(index.isFK()){
        columns = index.getColumns();
        if(columns.length>0){
          newIndex = getIndex(table,columns);       
          if(newIndex==null){         
            newIndex = table.createIndex();
            newIndex.setName('IDX_' + table.getName() + '_' + pad(++tablesIndexSequence, 2));
            table.setDirty(true);
            for (var k = 0; k < columns.length; k++){
              newIndex.add(columns[k]);
            }
          }
        }
      }
    }
  }
}

/*============================================================================*/

/**
 * This custom transformation aims to spot invalid index names, and then
 * normalize its name according to name formation rules.
 * 
 * See https://www.tjrs.gov.br/sistemas/redmine/projects/dc34vcqwe4/wiki/Padr%C3%A3o_de_Nome_de_Objetos_de_Banco_de_Dados
 */
function normalizeIndexName() {
  // Variable to store sequences for index name for
  // each table from the model. This sequence will be used
  // to form the index name, when it does not follow the naming
  // formation rule.
  var tablesIndexSequence;

  // Search for the highest index sequence by
  // transversing pIndexes array;
  function initIndexSequence(pIndexes, pTable) {

  	indexSequenceTmp = 1;
  	indexSequenceRet = 1;
  	colision         = false;
  	  	
  	for (var seq = 0; seq < pIndexes.length; seq++) {
  		indexTmp = pIndexes[seq];

          // Discard PK index in search of highest index
          // sequence.
  		if (!indexTmp.isPK()) {
  		   indexNameTmp = "IDX_" + pTable.getName() + "_" + pad(indexSequenceTmp++, 2);
  		   indexTmp     = null;
  		   indexTmp     = pTable.getIndexByName(indexNameTmp);

  		   if (indexTmp != null) {
  			 indexSequenceRet = indexSequenceTmp;
  			 colision = true;
  		   }
  	     }
  	}

  	return (colision ? indexSequenceRet : 1);
  }

  tables = model.getTableSet().toArray();
  for (var t = 0; t < tables.length; t++) {
  	tableTmp = tables[t];
     indexes  = tableTmp.getKeys();
     tablesIndexSequence = initIndexSequence(indexes, tableTmp);
     for (var i = 0; i < indexes.length; i++) {
        index = indexes[i];             
        if (!isValidIndexName(index)) {
        	// Set the new index name based on naming rule.
        	// For PK index, the sequence will be discarded.
          //index.setName((index.isPK() ? "PK_" : "IDX_") + tableTmp.getName() + "_" + pad(tablesIndexSequence++, 2));

          index.setName((index.isPK() ? "PK_" : "IDX_") + tableTmp.getName() + (index.isPK() ? "" : "_" + pad(tablesIndexSequence++, 2)));
          
          tableTmp.setDirty(true);
        }
     }
  }
}

/*============================================================================*/

/**
 * This Design rule aims to spot table which
 * have no primary key.
 * 
 * Parameters
 *   table: a given table object
 * Returns
 *    Boolean. True if the design rule is satisfied,
 *             otherwise False.
 */
function tableWithOutPK(table) {

  // Stores the result of this custom
  // design rule.
  result        = true;

  // Try to retrieve the table's PK.
  pk = table.getPK();

  if (pk == null) {
  	ruleMessage = "there is no primary key for this table.";
     errType     = "Error";
     result      = false;
  }

  return result;
}

/*============================================================================*/

/**
 * This Design rule aims to spot table which
 * have no expected volume registered in the model.
 * 
 * Parameters
 *   table: a given table object
 * Returns
 *    Boolean. True if the design rule is satisfied,
 *             otherwise False.
 */

function tableWithOutVolumetry(table) {

  // Stores the result of this custom
  // design rule.
  result        = true;	

  // Get the expected amount of rows
  expectedVolume = table.getExpectedVolumes();

  if (expectedVolume == 0 || expectedVolume == null) {
  	ruleMessage = "the table property 'Expected' cannot be 0 or null. Check table's Volume Properties.";
     errType     = "Error";
     result      = false;
  }

  return result;  
}

/*============================================================================*/

/**
 * This Design rule aims to spot table which
 * have no expected volume property registered in the model.
 * 
 * Parameters
 *   table: a given table object
 * Returns
 *    Boolean. True if the design rule is satisfied,
 *             otherwise False.
 */

function tableWithOutVolumetry(table) {

  // Stores the result of this custom
  // design rule.
  result        = true;	

  // Get the expected amount of rows
  expectedVolume = table.getExpectedVolumes();

  if (expectedVolume == 0 || expectedVolume == null) {
  	ruleMessage = "the table property 'Expected' cannot be 0 or null. Check table's Volume Properties.";
     errType     = "Error";
     result      = false;
  }

  return result;  
}

/*============================================================================*/

/**
 * This Design rule aims to spot table which
 * have no compression property assigned to it.
 * 
 * Parameters
 *   table: a given table object
 * Returns
 *    Boolean. True if the design rule is satisfied,
 *             otherwise False.
 */
function tableWithOutDataCompression(table) {

  // Stores the result of this custom
  // design rule.
  result        = true;	

  // Get the expected amount of rows
  expectedVolume = table.getExpectedVolumes();

  if (expectedVolume == 0 || expectedVolume == null) {
  	ruleMessage = "the table property 'Expected' cannot be 0 or null. Check table's Volume Properties.";
     errType     = "Error";
     result      = false;
  }

  return result;  
}

/**
 * The goal of this custom transformation script is to modify SQL command line
 * session to set stop running the script on failure behavior and force
 * the current schema to avoid to create the object in the wrong schema.
 * 
 * This function is being used by DDL Generator.
 */
function generateSQLConfiguration() {
	var cfgDDL;

	cfgDDL  = "\nPROMPT Configuracao do ambiente de execucao do SQL\n";
	cfgDDL += "WHENEVER SQLERROR EXIT FAILURE;\n";
	
     // Assumes that the first element from the array of users is
     // the correct user that represents the main model's schema.
     // There is opened at My Oracle Support, SR 3-19213495941, asking how to
     // get this information from Relational Model, Schemas rather than from
     // from Physcal Model.

     // ABS - TODO: find a solution to get the correct schema owner from
     //             model. Meanwhile, it will use <<AJUSTAR SCHEMA>> literal to
     //             avoid wrong schema mane for ALTER SESSION.
     //users = model.getStorageDesign().getUserSchemaSet().toArray();
     //user  = users[0];
     //cfgDDL += "ALTER SESSION SET CURRENT_SCHEMA=" + user.getName() + "\n\n";
     cfgDDL += "ALTER SESSION SET CURRENT_SCHEMA=<<AJUSTAR SCHEMA>>;\n";

	cfgDDL += "SET SCAN OFF;\n";
	cfgDDL += "SET ECHO ON;\n";
     cfgDDL += "SET TIMING ON;\n\n";
	
	// Add the configuration at the begining of DDL script
	ddlStatementsList.add(new java.lang.String(cfgDDL));
}

/*============================================================================*/

function getTableVolumetry(pTable) {
	
	var table = model.getTableSet().getByName(pTable.getName());
	var retVolumetry = 0;
	
	if (table != null) {
		retVolumetry = table.getExpectedVolumes();
	}
	
	return retVolumetry;
}

/*============================================================================*/

/**
 * The goal of this custom transformation script is to adjust
 * tables' storage parameters according to cient's standards.
 * For example, the right tablespace will be defined based on "expected rows"
 * property, stored in tables' metadata. There are a set of other properties that
 * will be adjusted as client's standards.
 */
function normalizeStorageProperties() {

	// Constants for properties to be updated in
	// the model.
	var DATA_COMPRESSION_YES  = "YES";
	var DATA_COMPRESSION_HIGH = "HIGH";
	var COMPRESSION_OLTP      = "OLTP";
	var LOB_STORAGE_TYPE_SEC  = "SECUREFILE";
	var LOB_DUP_TYPE_DEDUP    = "DEDUPLICATE";
	var LOB_CACHE_READS       = "CACHE READS";
	var LOB_CHUNK_ZERO        = 0;
	var LOB_VERSION_RETENTION = "RETENTION";

	// Table's Tablespace per expected rows
	var TABLE_TABLESPACE_SMALL  = "HP_1M_01D";
	var TABLE_TABLESPACE_MEDIUM = "HP_16M_01D";
	var TABLE_TABLESPACE_LARGE  = "HP_256M_01D";
	
	// Index's Tablespace per table expected rows
	var INDEX_TABLESPACE_SMALL  = "HP_1M_01X";
	var INDEX_TABLESPACE_MEDIUM = "HP_16M_01X";
	var INDEX_TABLESPACE_LARGE  = "HP_256M_01X";
	
	// Lob's Tablespace per table expected rows
	var LOB_TABLESPACE_SMALL  = "OA_1M_32K_01L";
	var LOB_TABLESPACE_MEDIUM = "OA_16M_32K_01L";
	var LOB_TABLESPACE_LARGE  = "OA_256M_32K_01L";

	// Volumetry ranges
	var START_RANGE_SMALL  = 1;
	var END_RANGE_SMALL    = 100000;
	var START_RANGE_MEDIUM = 100001;
	var END_RANGE_MEDIUM   = 1000000;
	var START_RANGE_LARGE  = 1000001;

	// Retrieve and process a set of tables from the Physical Model
	var tables = model.getStorageDesign().getTableProxySet().toArray();
	
	for (var i=0; i < tables.length; i++) {
		table = tables[i]
	
		// Adjust table compression and compression type
		if (table.getDataSegmentCompression() != DATA_COMPRESSION_YES) {
			table.setDataSegmentCompression(DATA_COMPRESSION_YES);
			table.setDirty(true);
		}
	
		if (table.getCompressionType() != COMPRESSION_OLTP) {
			table.setCompressionType(COMPRESSION_OLTP);
			table.setDirty(true);
		}
		
		// Adjust table's tablespace based on volumetry stored
		// in table's Relational Model section.
		tableVolumetry = getTableVolumetry(table);
		if (tableVolumetry != null) {
			if (tableVolumetry >= START_RANGE_SMALL && tableVolumetry <= END_RANGE_SMALL) {
				tableSpace = model.getStorageDesign().getTableSpaceSet().getByName(TABLE_TABLESPACE_SMALL);
				table.setTableSpace(tableSpace);
			} else if (tableVolumetry >= START_RANGE_MEDIUM && tableVolumetry <= END_RANGE_MEDIUM) {
				tableSpace = model.getStorageDesign().getTableSpaceSet().getByName(TABLE_TABLESPACE_MEDIUM);
				table.setTableSpace(tableSpace);
			} else if (tableVolumetry >= START_RANGE_LARGE) {
				tableSpace = model.getStorageDesign().getTableSpaceSet().getByName(TABLE_TABLESPACE_LARGE);
				table.setTableSpace(tableSpace);
			}
		}

	     // Adjust table indexes' tablespace based on volumetry stored
		// in table's Relational Model section.
	     tableIndexes = table.getIndexes().toArray();
	     for (var x=0; x < tableIndexes.length; x++) {
	     	tableIndex = tableIndexes[x];
	     	if (tableVolumetry != null) {
	     		if (tableVolumetry >= START_RANGE_SMALL && tableVolumetry <= END_RANGE_SMALL) {
	     			tableSpace = model.getStorageDesign().getTableSpaceSet().getByName(INDEX_TABLESPACE_SMALL);
	     			tableIndex.setTableSpace(tableSpace);
	     		} else if (tableVolumetry >= START_RANGE_MEDIUM && tableVolumetry <= END_RANGE_MEDIUM) {
	     			tableSpace = model.getStorageDesign().getTableSpaceSet().getByName(INDEX_TABLESPACE_MEDIUM);
	     			tableIndex.setTableSpace(tableSpace);
	     		} else if (tableVolumetry >= START_RANGE_LARGE) {
	     			tableSpace = model.getStorageDesign().getTableSpaceSet().getByName(INDEX_TABLESPACE_LARGE);
	     			tableIndex.setTableSpace(tableSpace);
	     		}

	     		tableIndex.setDirty(true);
	     	}
	     }
	     
		// Adjust table's Lob Storage ans Tablespace, just in case it exists for the underlying table,
		// as follows:
		tableLobStorages = table.getLobStorages().toArray();
		for (var k=0; k < tableLobStorages.length; k++) {
			tableLobStorage = tableLobStorages[k];
			
			tableLobStorage.setLobStorageType(LOB_STORAGE_TYPE_SEC);
			tableLobStorage.setCompression(DATA_COMPRESSION_YES);
			tableLobStorage.setCompressionType(DATA_COMPRESSION_HIGH);
			tableLobStorage.setDuplication(LOB_DUP_TYPE_DEDUP);
			tableLobStorage.setCache(LOB_CACHE_READS);
			tableLobStorage.setChunk(LOB_CHUNK_ZERO);
			tableLobStorage.setOldVersions(LOB_VERSION_RETENTION);

	     	if (tableVolumetry != null) {
	     		if (tableVolumetry >= START_RANGE_SMALL && tableVolumetry <= END_RANGE_SMALL) {
	     			tableSpace = model.getStorageDesign().getTableSpaceSet().getByName(LOB_TABLESPACE_SMALL);
	     			tableLobStorage.setTableSpace(tableSpace);
	     		} else if (tableVolumetry >= START_RANGE_MEDIUM && tableVolumetry <= END_RANGE_MEDIUM) {
	     			tableSpace = model.getStorageDesign().getTableSpaceSet().getByName(LOB_TABLESPACE_MEDIUM);
	     			tableLobStorage.setTableSpace(tableSpace);
	     		} else if (tableVolumetry >= START_RANGE_LARGE) {
	     			tableSpace = model.getStorageDesign().getTableSpaceSet().getByName(LOB_TABLESPACE_LARGE);
	     			tableLobStorage.setTableSpace(tableSpace);
	     		}
	     	}
	     	
			table.setDirty(true);
		}
	}
}

/*============================================================================*/

/**
 * This Design rule aims to spot table which
 * wrong tablespace assingment, based on table's "Volume Properties",
 * "Expected" property.
 * 
 * Parameters
 *   table: a given table object
 * Returns
 *    Boolean. True if the design rule is satisfied,
 *             otherwise False.
 */
function validateTableTablespaceUsage(table) {
	// Table's Tablespace per expected rows
	var TABLE_TABLESPACE_SMALL  = "HP_1M_01D";
	var TABLE_TABLESPACE_MEDIUM = "HP_16M_01D";
	var TABLE_TABLESPACE_LARGE  = "HP_256M_01D";
	
	// Index's Tablespace per table expected rows
	var INDEX_TABLESPACE_SMALL  = "HP_1M_01X";
	var INDEX_TABLESPACE_MEDIUM = "HP_16M_01X";
	var INDEX_TABLESPACE_LARGE  = "HP_256M_01X";
	
	// Lob's Tablespace per table expected rows
	var LOB_TABLESPACE_SMALL  = "OA_1M_32K_01L";
	var LOB_TABLESPACE_MEDIUM = "OA_16M_32K_01L";
	var LOB_TABLESPACE_LARGE  = "OA_256M_32K_01L";

	// Volumetry ranges
	var START_RANGE_SMALL  = 1;
	var END_RANGE_SMALL    = 100000;
	var START_RANGE_MEDIUM = 100001;
	var END_RANGE_MEDIUM   = 1000000;
	var START_RANGE_LARGE  = 1000001;

	var result = true;

	// Before move on check table's volumetry property
	if (!tableWithOutVolumetry(table)) {
		return false;
	}

	// Gets the reference to the model
	model = table.getDesignPart();

	// Retrieve from physical model the table storage
	tableStorage = model.getStorageDesign().getStorageObject(table.getObjectID());

	// Gets the tablespace assigned to the table
     tableTablespace = tableStorage.getTableSpace();
     
	// Gets the expected amount of rows 
	tableVolumetry = table.getExpectedVolumes();

     // Validate tablespace being used by the table based on its volumetry
	if (tableVolumetry != null) {
		ruleMessage  = "Invalid tablespace definition. Using "
		if (tableVolumetry >= START_RANGE_SMALL && tableVolumetry <= END_RANGE_SMALL) {
			if (!tableTablespace.getName().equals(TABLE_TABLESPACE_SMALL)) {
				result       = false;
				ruleMessage += tableTablespace;
				ruleMessage += " instead of " + TABLE_TABLESPACE_SMALL;
				errType      = "Error";
			}
		} else if (tableVolumetry >= START_RANGE_MEDIUM && tableVolumetry <= END_RANGE_MEDIUM) {
			if (!tableTablespace.getName().equals(TABLE_TABLESPACE_MEDIUM)) {
				result       = false;
				ruleMessage += tableTablespace;
				ruleMessage += " instead of " + TABLE_TABLESPACE_MEDIUM;
				errType      = "Error";
			}
		} else if (tableVolumetry >= START_RANGE_LARGE) {
			if (!tableTablespace.getName().equals(START_RANGE_LARGE)) {
				result       = false;
				ruleMessage += tableTablespace;
				ruleMessage += " instead of " + TABLE_TABLESPACE_LARGE;
				errType      = "Error";
			}
		}
	}

	return result;
}

/*============================================================================*/

/**
 * This Design rule aims to spot sequences that use the NOCACHE option.
 * NOCACHE must be used it caution and then the review by developer and/or
 * system analyst is needed.
 * 
 * Parameters
 *   table: a given table object
 * Returns
 *    Boolean. True if the design rule is satisfied,
 *             otherwise False.
 */
function sequencesWithNOCACHE(table) {
	var result = true;

	// Gets the reference to the model
	var model = table.getDesignPart();

	// Retrieve from physical model the sequence set
	var sequenceSet = model.getStorageDesign().getStorageObjectSetForType('Sequence');

     // Clear the design rule's content
     ruleMessage        = "";
     
     // Gets the Uder Defined Preferen to control the design rule
     // execution.
     var setting        = model.getAppView().getSettings();
     var validationDone = setting.getUserDefinedPreferenceValue("VALIDATED");

     if (validationDone.equalsIgnoreCase("false")) {
        //sequencesWithNOCACHE(table);

        // Set the UDF "VALIDATED" to "true" in order to run
        // this design rule once. The reason is that the sequences are
        // retrieved in the first object (table) feteched by the Javascript
        // runtime. Then the remaining table will be dismissed by this design rule once
        // the UDF "VALIDATED" was set to "true" in the first iteration.
        setting.addUserDefinedPreference("VALIDATED","true");

        javax.swing.JOptionPane
          .showMessageDialog
           (null, 
            "Please update the User Defined Preference 'VALIDATED' to 'false'.",
            "Action required",
            javax.swing.JOptionPane.INFORMATION_MESSAGE
           );
     }
     else {
     	return result;
     }
     
	sequenceArray = sequenceSet.toArray();

	for (var i=0; i < sequenceArray.length; i++) {
		sequence = sequenceArray[i];

		if (sequence.getNoCache().equalsIgnoreCase("YES")) {
			ruleMessage += " sequence " + sequence.getName() + " is defined as NOCACHE. Please, validate it with system analyst;";
			result = false;
		}
	}

	return result;
}]]>
		</script>
	</lib>

	<ruleset id="306F67CF-F630-1293-27FD-8E186D5F4002" name="TJRS-Validacoes Integradas do Modelo">
			<rule id="273541C2-9F46-A972-510C-146B117AE338"/>
			<rule id="4091D7C0-AD54-B648-024F-FDD7E7B7D401"/>
			<rule id="B0F0E2CA-6F41-463F-73A0-17FB99716AC6"/>
			<rule id="D52311F1-3FF2-EA90-8157-86E7A7C03776"/>
			<rule id="756DE154-799A-42CB-7E46-A162B768E6B6"/>
			<rule id="679189F6-E6A8-5409-FEA3-31B6DC8A462D"/>
	</ruleset>

	<ddl_transformation_script_set id="B4E65BCB-CFF5-1302-E0BC-0C329BF9890E" name="Journal tables" description="" active="false">
			<script id="9836D087-881D-2161-19AF-2C6DF49A964A"/>
			<script id="1C0CDD35-A0D6-47E5-C702-7FB537C8A8C0"/>
			<script id="B50F3C56-0DC4-6376-8CF9-9CB189DC97DD"/>
			<script id="DC383793-5C2E-F62A-5241-35B8ACE86134"/>
	</ddl_transformation_script_set>
	<ddl_transformation_script_set id="86649BAE-547E-99D5-8B00-54B3BB9BB6BB" name="Empty script" description="" active="false">
			<script id="0DC38187-8245-8904-7E00-D4B6DF394899"/>
			<script id="27EEAD3F-3367-9D6F-8E02-D44189C855A1"/>
			<script id="83D0D285-DF95-0BE7-EF4F-AC3F2D9CDE94"/>
			<script id="6FDC20F3-D5B1-9711-C93F-745217AC8664"/>
	</ddl_transformation_script_set>
	<ddl_transformation_script_set id="B4CFFC4A-4FFD-EB9D-E5D4-FFCC3D7AE5B8" name="TJRS - Alter SQL session configuration" description="Adiciona no script SQL comandos para alterar o comportamento da sessao do SQL para forcar para da execucao do script em caso de erro, bem como para mudar o schema corrente para o schema onde os objetos serao criados." active="true">
			<script id="B9B01780-AA07-A433-58F9-92F2E97272D7"/>
			<script id="82E2A003-E149-0C58-0BE9-0F8DCE476F39"/>
			<script id="CBC5F1A0-943E-59B6-2704-628565749E21"/>
			<script id="4C4DAF7D-51E6-95A5-55E5-08280F999D95"/>
	</ddl_transformation_script_set>
	<ddl_transformation_script_set id="B4E65BCB-CFF5-1302-E0BC-0C329BF9890E" name="Journal tables" description="" active="false">
			<script id="9836D087-881D-2161-19AF-2C6DF49A964A"/>
			<script id="1C0CDD35-A0D6-47E5-C702-7FB537C8A8C0"/>
			<script id="B50F3C56-0DC4-6376-8CF9-9CB189DC97DD"/>
			<script id="DC383793-5C2E-F62A-5241-35B8ACE86134"/>
	</ddl_transformation_script_set>
	<ddl_transformation_script_set id="86649BAE-547E-99D5-8B00-54B3BB9BB6BB" name="Empty script" description="" active="false">
			<script id="0DC38187-8245-8904-7E00-D4B6DF394899"/>
			<script id="27EEAD3F-3367-9D6F-8E02-D44189C855A1"/>
			<script id="83D0D285-DF95-0BE7-EF4F-AC3F2D9CDE94"/>
			<script id="6FDC20F3-D5B1-9711-C93F-745217AC8664"/>
	</ddl_transformation_script_set>
	<ddl_transformation_script_set id="B4CFFC4A-4FFD-EB9D-E5D4-FFCC3D7AE5B8" name="TJRS - Alter SQL session configuration" description="Adiciona no script SQL comandos para alterar o comportamento da sessao do SQL para forcar para da execucao do script em caso de erro, bem como para mudar o schema corrente para o schema onde os objetos serao criados." active="true">
			<script id="B9B01780-AA07-A433-58F9-92F2E97272D7"/>
			<script id="82E2A003-E149-0C58-0BE9-0F8DCE476F39"/>
			<script id="CBC5F1A0-943E-59B6-2704-628565749E21"/>
			<script id="4C4DAF7D-51E6-95A5-55E5-08280F999D95"/>
	</ddl_transformation_script_set>
</dr_custom_scripts>