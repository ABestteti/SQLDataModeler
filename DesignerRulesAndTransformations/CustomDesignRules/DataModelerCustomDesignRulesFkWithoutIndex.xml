<?xml version="1.0" encoding="UTF-8" ?>
<!-- File contains Custom Validation Scripts -->
<custom__validation_scripts>
	<scr id="D36CE536-D575-BE5C-625F-23DE23913C6B" name="Complex rule - check comments demo" object="Table" engine="Oracle Nashorn" type="Warning" var="table" library="my first library" method="checkcomments" purpose="validation" >
		<script>
			<![CDATA[]]>
		</script>
	</scr>
	<scr id="D72E63EC-9DA2-3537-F8C9-AE8ACEDC73D2" name="Length of Not Null Constraint name" object="Column" engine="Oracle Nashorn" type="Error" var="column" library="my first library" method="NotNullConstr_Name_Length" purpose="validation" >
		<script>
			<![CDATA[]]>
		</script>
	</scr>
	<scr id="3F2B77AE-F97F-EF6D-4D6D-C9FE4CC78999" name="Optional FK with mandatory columns" object="Index/Constraint" engine="Oracle Nashorn" type="Warning" var="index" library="" method="" purpose="validation" >
		<script>
			<![CDATA[var index;
// define function - function parameter doesn't need to be named index
function checkFKColumns(index){
  //check it's foreign key index, otherwise FK is null
 if(index.isFK()){
 	if(!index.getFKAssociation().isMandatory()){
	 cols = index.getElements();
	 for(var i=0;i<cols.length;i++){
		if(cols[i].isMandatory()){
			return false;
		}
	 }
 	}
 }
 return true;
}
// invoke the function
checkFKColumns(index);]]>
		</script>
	</scr>
	<scr id="55EE956C-2003-7051-CCA6-C69D87B4D91A" name="FK without index" object="Table" engine="Oracle Nashorn" type="Error" var="table" library="" method="null" purpose="validation" >
		<script>
			<![CDATA[// This Design rule aims to spot foreign key constraints which
// have no index to support it.

// Variable used to return custom message
var ruleMessage;

// Variables used to return the type of the ruler Error
// or Warning and red/blue  color will be used for result
// if another custom type is returned (Problem in the rule below)
// then result is colored in yellow.
var errType;

function foreignKeyWithOuIndex(pTable) {

  // Stores the list of table's keys, 
  // and then iterate over it.
  indexes       = pTable.getKeys();

  // Stores the result of this custom
  // design rule.
  result        = true;

  // Helps to control message text composition.
  newIndexCount = 0;

  // The error message template.
  ruleMessage   = "There is no index for constraint(s):";
	
  // Return an index reference for a given table and
  // column set
  function getIndex(tab,cols){
    keys = tab.getKeys();
    for (var i = 0; i < keys.length; i++) {
      indexTmp = keys[i];
      if(!(indexTmp.isPK() || indexTmp.isUnique()) && !indexTmp.isFK() && indexTmp.isIndexForColumns(cols)){
        return indexTmp
      }
    }
    return null;
  }
  
  for (var i = 0; i < indexes.length; i++) {
    index = indexes[i];
    if (index.isFK()){
      columns = index.getColumns();
      if (columns.length>0){
        newIndex = getIndex(pTable,columns);
        if (newIndex==null){

          separator    = (++newIndexCount > 1) ? "; " : " ";
          
          ruleMessage += separator + index.getName();
          errType      = "Error";
          result       = false;
        }
      }
    }
  }
  return result;
}
// invoke the function
foreignKeyWithOuIndex(table);]]>
		</script>
	</scr>
	<scr id="FAFC5BB0-8509-5709-123D-3C245059FAEA" name="Index with invalid name" object="Table" engine="Oracle Nashorn" type="Error" var="table" library="" method="null" purpose="validation" >
		<script>
			<![CDATA[// This Design rule aims to spot indexes, which as not compliance
// with name formation rule.

// Variable used to return custom message
var ruleMessage;

// Variables used to return the type of the ruler Error
// or Warning and red/blue  color will be used for result
// if another custom type is returned (Problem in the rule below)
// then result is colored in yellow.
var errType;

function pkWithInvalidName(pTable) {
	
  // Stores the list of table's keys, 
  // and then iterate over it.
  indexes = pTable.getKeys();

  // Stores the result of this custom
  // design rule.
  result  = true;  

  // Validade the index name, through a ReGex, based on the following
  // document:
  // https://www.tjrs.gov.br/sistemas/redmine/projects/dc34vcqwe4/wiki/Padr%C3%A3o_de_Nome_de_Objetos_de_Banco_de_Dados
  // Parameter
  //   pIndexName: a index name
  // Returns
  //   boolean
  function isValidIndexName(pIndexName) {
  	// Regular expression to match an index name
  	// For more information, acess: https://regex101.com/r/aA8hI6/1
  	// 
  	// Rationale: ^IDX\_.+\_\d{2}$
     //   ^ asserts position at start of a line
     //   IDX matches the characters IDX literally (case sensitive)
     //   \_ matches the character _ literally (case sensitive)
     //   .+ matches any character (except for line terminators)
     //   + Quantifier — Matches between one and unlimited times, as many times as possible, giving back as needed (greedy)
     //   \_ matches the character _ literally (case sensitive)
     //   \d{2} matches a digit (equal to [0-9])
     //   {2} Quantifier — Matches exactly 2 times
     //   $ asserts position at the end of a line  	 
     regexp = /^IDX\_.+\_\d{2}$/i;    	 
    	return regexp.test(pIndexName);
  }
  
  for (var i = 0; i < indexes.length; i++) {
    index = indexes[i];
    if (!index.isPK()){
    	 if (!isValidIndexName(index.getName())) {
    	   ruleMessage  = "The index " + index.getName();
    	   ruleMessage += " has an invalid name. It must be IDX_"
    	   ruleMessage += pTable.getName() + "_NN, where NN is a two digits number.";
    	   errType = "Error";
    	   return false;
    	 }
    }
  }
  return result;
}
// invoke the function
pkWithInvalidName(table);]]>
		</script>
	</scr>
</custom__validation_scripts>