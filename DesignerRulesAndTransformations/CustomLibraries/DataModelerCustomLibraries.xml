<?xml version="1.0" encoding="UTF-8" ?>
<!-- File contains Custom Libraries Scripts -->
<custom_libraries>
	<lib id="B310E434-78AE-6AED-EA94-6808B0262483" name="my first library" engine="Oracle Nashorn" methods="checkcomments,NotNullConstr_Name_Length" >
		<script>
			<![CDATA[// variable used to return custom message
var ruleMessage;
// variable used to return the type of the rule Error
// or Warning and red/blue color will be used for result
// if another custom type is returned (Problem in the rule below) 
// then result is colored in yellow
var errType;
var table;
function checkcomments(object){
 result = true;
 ruleMessage="";
 if(table.getCommentInRDBMS().equals("")){
  ruleMessage="no comments in RDBMS defined";
  errType="Problem:";
  result = false;
 }
 if(table.getComment().equals("")){
  if(ruleMessage.equals("")){
   ruleMessage="no comments defined";
  }else{
   ruleMessage= ruleMessage +" , no comments defined";
   }
   // can be changed to Warning    
   errType="Error";
  return false;
 }
 return result;
}
//rule for not null constraint name
function NotNullConstr_Name_Length(column){
 model = column.getDesignPart();
 name = column.getNotNullConstraintName();
 result = true;
 if(name!=null && !"".equals(name)){
	holder = model.getNamingOptionsHolderFor("oracle.dbtools.crest.model.design.constraint.TableLevelConstraint");
	if ((holder.getMaxNameLength() > 0) && (name.length() > holder.getMaxNameLength())) {
		result = false;
	}
 }
 return result
}]]>
		</script>
	</lib>
	<lib id="2518F33A-DE50-9E1D-7216-DD2A0FD6B84C" name="Jruby lib" engine="JSR 223 JRuby Engine" methods="tables_up" >
		<script>
			<![CDATA[def tables_up(model)
tables = model.getTableSet().toArray()
for t in 0..tables.length-1
 table = tables[t]
 name = table.getName().upcase
 table.setName(name)
 columns = table.getElements()
 size = table.getElementsCollection().size()-1
 for i in 0..size
	column = columns[i]
	cname = column.getName().upcase
	column.setName(cname)
 end
 keys = table.getKeys()
 for i in 0..keys.length-1
  key = keys[i]
  kname = key.getName().upcase
  key.setName(kname)
 end
end
return true
end]]>
		</script>
	</lib>
	<lib id="79C2ED6C-9A18-434F-F0FE-838F87B60814" name="TJRS lib" engine="Oracle Nashorn" methods="versaoBiblioteca,indexWithInvalidName,FKWithOutIndex,createIndexOnFK,normalizeIndexName,tableWithOutPK" >
		<script>
			<![CDATA[// Variable used to return custom message
var ruleMessage;
  
// Variables used to return the type of the ruler Error
// or Warning and red/blue  color will be used for result
// if another custom type is returned (Problem in the rule below)
// then result is colored in yellow.
var errType;

/*============================================================================*/

function versaoBiblioteca() {
  var versao = "Versão: 1.0.17.01.2019";
  var titulo = "TJRS - Biblioteca de scripts";

  javax.swing.JOptionPane
     .showMessageDialog
     (null, 
      versao,
      titulo,
      javax.swing.JOptionPane.INFORMATION_MESSAGE
     );
}

/*============================================================================*/

/**
 * Validate the index name, through a ReGex, based on the following
 * document:
 * https://www.tjrs.gov.br/sistemas/redmine/projects/dc34vcqwe4/wiki/Padr%C3%A3o_de_Nome_de_Objetos_de_Banco_de_Dados
 * Parameter
 *   pIndex: a index object
 * Returns
 *   Boolean. True if the index name conforms to index name rule, 
 *            otherwise False.
 */
function isValidIndexName(pIndex) {
   /**
    * Regular expression to match an index name
    * For more information, acess: https://regex101.com/r/aA8hI6/1
    * 
    * Rationale: ^IDX\_.+\_\d{2}$ or /^PK\_.+\_\d{2}$/i
    *   ^ asserts position at start of a line
    *   IDX matches the characters IDX literally (case sensitive)
    *   \_ matches the character _ literally (case sensitive)
    *   .+ matches any character (except for line terminators)
    *   + Quantifier — Matches between one and unlimited times, as many times as possible, giving back as needed (greedy)
    *   \_ matches the character _ literally (case sensitive)
    *   \d{2} matches a digit (equal to [0-9])
    *   {2} Quantifier — Matches exactly 2 times
    *   $ asserts position at the end of a line
    */
   regexp = (pIndex.isPK() ? /^PK\_.+\_\d{2}$/i : /^IDX\_.+\_\d{2}$/i);
   
   return regexp.test(pIndex.getName());
}

/*============================================================================*/

/**
 * Pad zeros to a given number
 * 
 * Parameters
 *   num: a number to be paded
 *   size: leftmost zeroes to pad
 * Returns
 *   The number with leftmost zeroes
 */
function pad(num, size) {
   var s = num+"";
   while (s.length < size) s = "0" + s;
   return s;
}

/*============================================================================*/

/**
 * This Design rule aims to spot indexes, which as not compliance
 * with name formation rule.
 * 
 * Parameters
 *    table: a given table object
 * Returns
 *    Boolean. True if the design rule is satisfied,
 *             otherwise False.
 */
function indexWithInvalidName(table) {

  // Stores the result of this custom
  // design rule.
  result  = true;  

  // Stores the list of table's keys, 
  // and then iterate over it.
  indexes = table.getKeys();
  
  for (var i = 0; i < indexes.length; i++) {
    index = indexes[i];
    if (!index.isPK()){
    	 if (!isValidIndexName(index)) {
    	   ruleMessage  = "The index " + index.getName();
    	   ruleMessage += " has an invalid name. It must be IDX_"
    	   ruleMessage += table.getName() + "_NN, where NN is a two digits number.";
    	   errType = "Error";
    	   return false;
    	 }
    }
  }
  return result;
}

/*============================================================================*/

/**
 * This Design rule aims to spot foreign key constraints which
 * have no index to support it.
 * 
 * Parameters
 *   table: a given table object
 * Returns
 *    Boolean. True if the design rule is satisfied,
 *             otherwise False.
 */
function FKWithOutIndex(table) {

  // Stores the list of table's keys, 
  // and then iterate over it.
  indexes       = table.getKeys();

  // Stores the result of this custom
  // design rule.
  result        = true;

  // Helps to control message text composition.
  newIndexCount = 0;

  // The error message template.
  ruleMessage   = "There is no index for constraint(s):";
	
  // Return an index reference for a given table and
  // column set
  function getIndex(tab,cols){
    keys = tab.getKeys();
    for (var i = 0; i < keys.length; i++) {
      indexTmp = keys[i];
      if(!(indexTmp.isPK() || indexTmp.isUnique()) && !indexTmp.isFK() && indexTmp.isIndexForColumns(cols)){
        return indexTmp
      }
    }
    return null;
  }
  
  for (var i = 0; i < indexes.length; i++) {
    index = indexes[i];
    if (index.isFK()){
      columns = index.getColumns();
      if (columns.length>0){
        newIndex = getIndex(table,columns);
        if (newIndex==null){
          separator    = (++newIndexCount > 1) ? "; " : " ";          
          ruleMessage += separator + index.getName();
          errType      = "Error";
          result       = false;
        }
      }
    }
  }
  return result;
}

/*============================================================================*/

/**
 * This custom transformation aims to spot FKs with have no index
 * and then create the index definition to support it.
 */
function createIndexOnFK() {
  function getIndex(tab,cols){
   keys = tab.getKeys();
   for (var i = 0; i < keys.length; i++) {
    indexTmp = keys[i];
    if(!(indexTmp.isPK() || indexTmp.isUnique()) && !indexTmp.isFK() && indexTmp.isIndexForColumns(cols)){
       return indexTmp
     }
   }
   return null;
  }
  
  // Variable to store sequences for index name for
  // each table from the model. This sequence will be used
  // to form the index name, when it does not follow the naming
  // formation rule.
  var tablesIndexSequence;
  
  tables = model.getTableSet().toArray();
  for (var t = 0; t<tables.length;t++){
    table = tables[t];
    tablesIndexSequence = 0;
    indexes = table.getKeys();
    for (var i = 0; i < indexes.length; i++) {
       index = indexes[i];
       if(index.isFK()){
        columns = index.getColumns();
        if(columns.length>0){
          newIndex = getIndex(table,columns);       
          if(newIndex==null){         
            newIndex = table.createIndex();
            newIndex.setName('IDX_' + table.getName() + '_' + pad(++tablesIndexSequence, 2));
            table.setDirty(true);
            for (var k = 0; k < columns.length; k++){
              newIndex.add(columns[k]);
            }
          }
        }
      }
    }
  }
}

/*============================================================================*/

/**
 * This custom transformation aims to spot invalid index names, and then
 * normalize its name according to name formation rules.
 * 
 * See https://www.tjrs.gov.br/sistemas/redmine/projects/dc34vcqwe4/wiki/Padr%C3%A3o_de_Nome_de_Objetos_de_Banco_de_Dados
 */
function normalizeIndexName() {
  // Variable to store sequences for index name for
  // each table from the model. This sequence will be used
  // to form the index name, when it does not follow the naming
  // formation rule.
  var tablesIndexSequence;

  // Search for the highest index sequence by
  // transversing pIndexes array;
  function initIndexSequence(pIndexes, pTable) {

  	indexSequenceTmp = 1;
  	indexSequenceRet = 1;
  	colision         = false;
  	  	
  	for (var seq = 0; seq < pIndexes.length; seq++) {
  		indexTmp = pIndexes[seq];

          // Discard PK index in search of highest index
          // sequence.
  		if (!indexTmp.isPK()) {
  		   indexNameTmp = "IDX_" + pTable.getName() + "_" + pad(indexSequenceTmp++, 2);
  		   indexTmp     = null;
  		   indexTmp     = pTable.getIndexByName(indexNameTmp);

  		   if (indexTmp != null) {
  			 indexSequenceRet = indexSequenceTmp;
  			 colision = true;
  		   }
  	     }
  	}

  	return (colision ? indexSequenceRet : 1);
  }

  tables = model.getTableSet().toArray();
  for (var t = 0; t < tables.length; t++) {
  	tableTmp = tables[t];
     indexes  = tableTmp.getKeys();
     tablesIndexSequence = initIndexSequence(indexes, tableTmp);
     for (var i = 0; i < indexes.length; i++) {
        index = indexes[i];             
        if (!isValidIndexName(index)) {
        	// Set the new index name based on naming rule.
        	// For PK index, the sequence will be discarded.
          //index.setName((index.isPK() ? "PK_" : "IDX_") + tableTmp.getName() + "_" + pad(tablesIndexSequence++, 2));

          index.setName((index.isPK() ? "PK_" : "IDX_") + tableTmp.getName() + (index.isPK() ? "" : "_" + pad(tablesIndexSequence++, 2)));
          
          tableTmp.setDirty(true);
        }
     }
  }
}

/*============================================================================*/

/**
 * This Design rule aims to spot table which
 * have no primary key.
 * 
 * Parameters
 *   table: a given table object
 * Returns
 *    Boolean. True if the design rule is satisfied,
 *             otherwise False.
 */
function tableWithOutPK(table) {

  // Stores the result of this custom
  // design rule.
  result        = true;

  // Try to retrieve the table's PK.
  pk = table.getPK();

  if (pk == null) {
  	ruleMessage = "there is no primary key for this table.";
     errType     = "Error";
     result      = false;
  }

  return result;
}

/*============================================================================*/
/**
 * This Design rule aims to spot table which
 * have no expected volume registered in the model.
 * 
 * Parameters
 *   table: a given table object
 * Returns
 *    Boolean. True if the design rule is satisfied,
 *             otherwise False.
 */

function tableWithOutVolumery(table) {

  // Stores the result of this custom
  // design rule.
  result        = true;	
  
  expectedVolume = table.getExpectedVolumes();

  if (expectedVolume == 0 || expectedVolume == null) {
  	ruleMessage = "the table property 'Expected' cannot be 0 or null. Check table's Volume Properties.";
     errType     = "Error";
     result      = false;
  }

  return result;  
}
]]>
		</script>
	</lib>
</custom_libraries>