<?xml version="1.0" encoding="UTF-8" ?>
<displays>
<folder>
	<name><![CDATA[Schema Utils]]></name>
	<tooltip><![CDATA[Offer a set os schema reports]]></tooltip>
	<description><![CDATA[Offer a set os schema reports]]></description>
		<display id="ee286a15-0165-1000-8001-0ac80a6183e8" type="" style="Script" enable="true">
		<name><![CDATA[Schema Diff]]></name>
		<description><![CDATA[This report compares two schemas and it shows the bifferentes between them.]]></description>
		<tooltip><![CDATA[Compare two schemas to spot differences between them.]]></tooltip>
		<drillclass><![CDATA[]]></drillclass>
		<CustomValues>
		</CustomValues>
		<query>
			<sql><![CDATA[-- +----------------------------------------------------------------------------+
-- |                          Jeffrey M. Hunter                                 |
-- |                      jhunter@idevelopment.info                             |
-- |                         www.idevelopment.info                              |
-- |----------------------------------------------------------------------------|
-- |      Copyright (c) 1998-2015 Jeffrey M. Hunter. All rights reserved.       |
-- |                                                                            |
-- | 09/18/2018: Anderson Bestteti - InterOp                                    |
-- |             Script changed to compare two schemas within and Oracle        |
-- |             instance.                                                      |
-- |----------------------------------------------------------------------------|
-- | DATABASE : Oracle                                                          |
-- | FILE     : dba_compare_schemas.sql                                         |
-- | CLASS    : Database Administration                                         |
-- | PURPOSE  : This script can be used by developers and DBAs to compare two   |
-- |            Oracle schemas. This script will generate a report of all       |
-- |            object discrepancies between two Oracle database schemas.       |
-- |                                                                            |
-- |            This script has been tested on the following Oracle database    |
-- |            versions:  7.3, 8, 8i, 9i, 10g, 11g.                            |
-- |                                                                            |
-- |            At this time, the following schema object types (and            |
-- |            attributes) are not compared and reported on within the         |
-- |            detailed discrepancy sections. Most of them, however, will      |
-- |            appear in the "Summary" section of the report.                  |
-- |                                                                            |
-- |            - Comments                    (On either tables nor columns.)   |
-- |            - Partitions                  (Introduced in Oracle8)           |
-- |            - Object types                (Introduced in Oracle8)           |
-- |            - Nested tables               (Introduced in Oracle8)           |
-- |            - Dimensions                  (Introduced in Oracle8i)          |
-- |            - Cluster definitions                                           |
-- |            - Auditing metadata                                             |
-- |            - Index organized tables      (Introduced in Oracle8i)          |
-- |            - Temporary tables            (Introduced in Oracle8i)          |
-- |            - Snapshots                   (Also known as materialized views |
-- |                                           in Oracle8 and higher. Also no   |
-- |                                           details on snapshot logs and     |
-- |                                           refresh groups will be           |
-- |                                           generated.)                      |
-- |            - New schema attributes       (Introduced in Oracle 9i)         |
-- |                                                                            |
-- | NOTE     : As with any code, ensure to test this script in a development   |
-- |            environment before attempting to run it in production.          |
-- +----------------------------------------------------------------------------+

SET PAGESIZE  50000
SET LINESIZE  256
SET TERMOUT   ON

PROMPT 
PROMPT +------------------------------------------------------------------------+
PROMPT | COMPARE SCHEMA SCRIPT                                                  |
PROMPT |------------------------------------------------------------------------|
PROMPT |                                                                        |
PROMPT | USAGE                                                                  |
PROMPT | -----------------------------------------------------------------------|
PROMPT | This SQL script should be run while connected to the Oracle database   |
PROMPT | as one of the schemas you would like to compare. You will be prompted  |
PROMPT | to enter the target schema you would like to compare against.          |
PROMPT +------------------------------------------------------------------------+
PROMPT 

COLUMN local_conn_info NEW_VALUE local_conn_info NOPRINT;
SELECT  'You are currently connected to the [' || 
        sys_context('USERENV', 'INSTANCE_NAME')  || '] instance as the [' ||
        sys_context('USERENV', 'SESSION_USER') || '] user. |' local_conn_info
FROM   dual;

PROMPT +------------------------------------------------------------------------+
PROMPT | LOCAL CONNECTION INFORMATION                                           |
PROMPT |------------------------------------------------------------------------|
PROMPT | &local_conn_info
PROMPT +------------------------------------------------------------------------+
PROMPT 

REM +---------------------------------------------------------------------------+
REM | PRINT OUT DATE AND TIME AND OTHER REPORT HEADER INFORMATION.              |
REM +---------------------------------------------------------------------------+

SELECT SUBSTR(RPAD(TO_CHAR(sysdate, 'DD-MON-YYYY HH24:MI:SS'), 25), 1, 25) "Report Date and Time"
FROM   dual;

SET TERMOUT OFF
COLUMN source_schema_dsp NEW_VALUE source_schema_dsp NOPRINT;
SELECT :source_schema source_schema_dsp FROM dual;

COLUMN target_schema_dsp NEW_VALUE target_schema_dsp NOPRINT;
SELECT :target_schema target_schema_dsp FROM dual;
SET TERMOUT ON

PROMPT +------------------------------------------------------------------------+
PROMPT | SCHEMAS EVALUEATED                                                     |
PROMPT |------------------------------------------------------------------------|
PROMPT | Source schema: &source_schema_dsp
PROMPT | Target schema: &target_schema_dsp
PROMPT +------------------------------------------------------------------------+
PROMPT 

COLUMN object_name    FORMAT a40            HEADING 'Object Name'
COLUMN object_type    FORMAT a40            HEADING 'Object Type'
COLUMN obj_count      FORMAT 999,999,999    HEADING 'Object Count'

SET HEADING  OFF
SET FEEDBACK OFF

PROMPT
SELECT '+------------------------------------------------------------------------+' || chr(10) ||
       '|                            OBJECT SUMMARY                              |' || chr(10) ||
       '+------------------------------------------------------------------------+'
FROM    dual;

SET HEADING  ON
SET FEEDBACK ON

PROMPT
PROMPT ========================================================
PROMPT Objects missing from &target_schema_dsp schema - (Summary)
PROMPT ========================================================

SELECT
    object_type
  , count(*)    obj_count
FROM
    (select
         object_type
       , decode(  object_type
                , 'INDEX', decode(substr(object_name, 1, 5), 'SYS_C', 'SYS_C', object_name)
                , 'LOB'  , decode(substr(object_name, 1, 7), 'SYS_LOB', 'SYS_LOB', object_name)
                , object_name)
     from  dba_objects
     where owner = UPPER(:target_schema)
     minus
     select
         object_type
       , decode(  object_type
                , 'INDEX', DECODE(SUBSTR(object_name, 1, 5), 'SYS_C', 'SYS_C', object_name)
                , 'LOB',   DECODE(SUBSTR(object_name, 1, 7), 'SYS_LOB', 'SYS_LOB', object_name),
                 object_name)
     from  dba_objects
     where owner = UPPER(:source_schema)
    )
GROUP BY object_type
ORDER BY object_type;

PROMPT
PROMPT
PROMPT ========================================================
PROMPT Extraneous objects in &source_schema_dsp schema - (Summary)
PROMPT ========================================================

SELECT
    object_type
  , count(*)    obj_count
FROM
    (select
         object_type
       , DECODE(   object_type
                 , 'INDEX', DECODE (SUBSTR (object_name, 1, 5), 'SYS_C',   'SYS_C',   object_name) 
                 , 'LOB',   DECODE (SUBSTR (object_name, 1, 7), 'SYS_LOB', 'SYS_LOB', object_name)
                 , object_name)
     from   dba_objects
     where  owner = UPPER(:source_schema)
     minus
     select
         object_type
       , DECODE(   object_type
                 , 'INDEX', DECODE (SUBSTR (object_name, 1, 5), 'SYS_C',   'SYS_C',   object_name)
                 , 'LOB',   DECODE (SUBSTR (object_name, 1, 7), 'SYS_LOB', 'SYS_LOB', object_name)
                 , object_name)
     from  dba_objects
     where owner = UPPER(:target_schema)
    )
GROUP BY object_type
ORDER BY object_type;

SET HEADING  OFF
SET FEEDBACK OFF
PROMPT
SELECT '+----------------------------------------------------------------------+' || chr(10) ||
       '|                          OBJECT DIFFERENCES                          |' || chr(10) ||
       '+----------------------------------------------------------------------+'
FROM    dual;

SET HEADING  ON
SET FEEDBACK ON

PROMPT
PROMPT ========================================================
PROMPT Objects missing from schema &source_schema_dsp
PROMPT ========================================================

SELECT
    DECODE(   object_type
            , 'INDEX', DECODE(SUBSTR(object_name, 1, 5), 'SYS_C', 'SYS_C', object_name)
            , 'LOB',   DECODE(SUBSTR(object_name, 1, 7), 'SYS_LOB', 'SYS_LOB', object_name)
            , object_name) object_name
  , object_type
FROM     dba_objects
WHERE    owner = UPPER(:target_schema)
MINUS
SELECT   
    DECODE(   object_type
            , 'INDEX', DECODE(SUBSTR(object_name, 1, 5), 'SYS_C', 'SYS_C', object_name)
            , 'LOB',   DECODE(SUBSTR(object_name, 1, 7), 'SYS_LOB', 'SYS_LOB', object_name)
            , object_name) object_name
  , object_type
FROM     dba_objects
WHERE    owner = UPPER(:source_schema)
ORDER BY object_type, object_name;

SET HEADING  OFF
SET FEEDBACK OFF

SELECT '+----------------------------------------------------------------------+' || chr(10) ||
       '|                      TABLE COLUMN DIFFERENCES                        |' || chr(10) ||
       '+----------------------------------------------------------------------+'
FROM    dual;

SET HEADING  ON
SET FEEDBACK ON

PROMPT
PROMPT ========================================================
PROMPT Table columns missing from one schema
PROMPT (Discrepancies are not listed in column order)
PROMPT ========================================================

COLUMN table_name     FORMAT a30  HEADING 'Table Name'
COLUMN column_name    FORMAT a30  HEADING 'Column Name'
COLUMN mis            FORMAT a17  HEADING 'Missing in Schema'
COLUMN schema         FORMAT a30  HEADING 'Schema'
COLUMN nullable       FORMAT a8   HEADING 'Nullable?'
COLUMN data_type      FORMAT a9   HEADING 'Data Type'
COLUMN data_length    FORMAT 9999 HEADING 'Length'
COLUMN data_precision FORMAT 9999 HEADING 'Precision'
COLUMN data_scale     FORMAT 9999 HEADING 'Scale'
COLUMN default_length FORMAT 9999 HEADING 'Length of Default Value'

( SELECT
    table_name,
    column_name,
    UPPER(:target_schema) mis
FROM
    dba_tab_columns
WHERE
    table_name IN (
        select table_name
        from   dba_tables
        where  owner = UPPER(:target_schema)
    )
    AND owner = UPPER(:source_schema)
MINUS
SELECT
    table_name,
    column_name,
    UPPER(:target_schema) mis
FROM
    dba_tab_columns
WHERE
    table_name IN (
        select table_name
        from   dba_tables
        where  owner = UPPER(:source_schema)
    )
    AND owner = UPPER(:target_schema)
)
UNION ALL
( SELECT
    table_name,
    column_name,
    UPPER(:source_schema) mis
FROM
    dba_tab_columns
WHERE
    table_name IN (
        select table_name
        from   dba_tables
        where  owner = UPPER(:source_schema)
    )
    AND owner = UPPER(:target_schema)
MINUS
SELECT
    table_name,
    column_name,
    UPPER(:source_schema) mis
FROM
    dba_tab_columns
WHERE
    table_name IN (
        select table_name
        from   dba_tables
        where  owner = UPPER(:target_schema)
    )
    AND owner = UPPER(:source_schema)
)
ORDER BY
    1,
    2;
    
PROMPT
PROMPT ========================================================
PROMPT Data type discrepancies for table columns that exist in 
PROMPT both schemas
PROMPT ========================================================

(
  SELECT
      table_name
    , column_name
    , UPPER(:target_schema) schema
    , nullable
    , data_type
    , data_length
    , data_precision
    , data_scale
    , default_length
  FROM  dba_tab_columns
  WHERE (table_name, column_name) IN (
            select table_name, column_name
            from   dba_tab_columns
            where owner = UPPER(:source_schema)
        )
  AND owner = UPPER(:target_schema)
  MINUS
  SELECT
      table_name
    , column_name
    , UPPER(:target_schema) schema
    , nullable
    , data_type
    , data_length
    , data_precision
    , data_scale
    , default_length
  FROM  dba_tab_columns
  WHERE owner = UPPER(:source_schema)
)
UNION ALL
(
  SELECT
      table_name
    , column_name
    , UPPER(:source_schema) schema
    , nullable
    , data_type
    , data_length
    , data_precision
    , data_scale
    , default_length
  FROM  dba_tab_columns
  WHERE (table_name, column_name) IN (
             select table_name, column_name
             from   dba_tab_columns
             where owner = UPPER(:target_schema)
         )
  AND  owner = UPPER(:source_schema)
  MINUS
  SELECT
      table_name
    , column_name
    , UPPER(:source_schema) schema
    , nullable
    , data_type
    , data_length
    , data_precision
    , data_scale
    , default_length
  FROM  dba_tab_columns
  WHERE owner = UPPER(:target_schema)
)
ORDER BY 1, 2, 3;

SET HEADING  OFF
SET FEEDBACK OFF

PROMPT
SELECT '+----------------------------------------------------------------------+' || chr(10) ||
       '|                          INDEX DIFFERENCES                           |' || chr(10) ||
       '+----------------------------------------------------------------------+'
FROM    dual;

SET HEADING  ON
SET FEEDBACK ON

COLUMN index_name       FORMAT a30   HEADING 'Index Name'
COLUMN schema           FORMAT a7    HEADING 'Schema'
COLUMN uniquenes                     HEADING 'Uniquenes'
COLUMN table_name       FORMAT a30   HEADING 'Table Name'
COLUMN column_name      FORMAT a30   HEADING 'Column Name'
COLUMN column_position  FORMAT 999   HEADING 'Order'

PROMPT
PROMPT ========================================================
PROMPT Index discrepancies for indexes that exist in both
PROMPT schemas &source_schema_dsp and &target_schema_dsp
PROMPT ========================================================

(
  SELECT
      a.index_name
    , UPPER(:target_schema) schema
    , a.uniqueness
    , a.table_name
    , b.column_name
    , b.column_position
  FROM
      dba_indexes      a
    , dba_ind_columns  b
  WHERE
        a.owner = UPPER(:target_schema)
    AND a.index_name IN (
           select index_name
           from   dba_indexes
           where  owner = UPPER(:source_schema)
        )
    AND b.index_owner = UPPER(:target_schema)
    AND b.index_name  = a.index_name
    AND b.table_name  = a.table_name
  MINUS
  SELECT
      a.index_name
    , UPPER(:target_schema) schema
    , a.uniqueness
    , a.table_name
    , b.column_name
    , b.column_position
  FROM
      dba_indexes      a
    , dba_ind_columns  b
  WHERE
        a.owner       = UPPER(:source_schema)
    AND b.index_name  = a.index_name
    AND b.index_owner = a.owner
    AND b.table_name  = a.table_name
)
UNION ALL
(
  SELECT
      a.index_name
    , UPPER(:source_schema) schema
    , a.uniqueness
    , a.table_name
    , b.column_name
    , b.column_position
  FROM
      dba_indexes      a
    , dba_ind_columns  b
  WHERE
        a.owner      = UPPER(:source_schema)
    AND a.index_name IN (
            select index_name
            from   dba_indexes
            where  owner = UPPER(:target_schema)
        )
    AND b.index_owner = UPPER(:source_schema)
    AND b.index_name  = a.index_name
    AND b.table_name  = a.table_name
  MINUS
  SELECT
      a.index_name
    , UPPER(:source_schema) schema
    , a.uniqueness
    , a.table_name
    , b.column_name
    , b.column_position
  FROM
      dba_indexes     a
    , dba_ind_columns b
  WHERE
        a.owner = UPPER(:target_schema)
    AND b.index_owner = a.owner
    AND b.index_name  = a.index_name
    AND b.table_name  = a.table_name
)
ORDER BY 1, 2, 6;

SET HEADING  OFF
SET FEEDBACK OFF

PROMPT
SELECT '+----------------------------------------------------------------------+' || chr(10) ||
       '|                       CONSTRAINT DIFFERENCES                         |' || chr(10) ||
       '+----------------------------------------------------------------------+'
FROM    dual;

SET HEADING  ON
SET FEEDBACK ON

SET FEEDBACK OFF
SET VERIFY   OFF
SET TERMOUT  OFF
CREATE TABLE schema_compare_temp (
    database     NUMBER(1)
  , object_name  VARCHAR2(30)
  , object_text  VARCHAR2(2000)
  , hash_value   NUMBER
)
/

DECLARE

    CURSOR c1 IS
        SELECT constraint_name, search_condition
        FROM   dba_constraints
        WHERE 
              owner = UPPER(:source_schema)
          AND search_condition IS NOT NULL;

    CURSOR c2 IS
        SELECT constraint_name, search_condition
        FROM   dba_constraints
        WHERE 
              owner = UPPER(:target_schema)
          AND search_condition IS NOT NULL;

    v_constraint_name  VARCHAR2(30);
    v_search_condition VARCHAR2(32767);

BEGIN

    OPEN c1;
    LOOP
        FETCH c1 INTO v_constraint_name, v_search_condition;
        EXIT WHEN c1%NOTFOUND;

        v_search_condition := SUBSTR (v_search_condition, 1, 2000);
        INSERT INTO schema_compare_temp (
            database, object_name, object_text
        ) VALUES (
            1, v_constraint_name, v_search_condition
        );
    END LOOP;
    CLOSE c1;

    OPEN c2;
    LOOP
        FETCH c2 INTO v_constraint_name, v_search_condition;
        EXIT WHEN c2%NOTFOUND;
        v_search_condition := SUBSTR (v_search_condition, 1, 2000);
        INSERT INTO schema_compare_temp (
            database, object_name, object_text
        ) VALUES (
            2, v_constraint_name, v_search_condition
        );
    END LOOP;
    CLOSE c2;

  COMMIT;
END;
/

SET TERMOUT  ON
SET FEEDBACK ON
SET VERIFY   OFF

COLUMN constraint_name   FORMAT a30   HEADING 'Constraint|Name'
COLUMN schema            FORMAT a30   HEADING 'Schema'
COLUMN constraint_type   FORMAT a10   HEADING 'Constraint|Type'
COLUMN table_name        FORMAT a30   HEADING 'Table|Name'
COLUMN r_constraint_name FORMAT a30   HEADING 'R Constraint|Name'
COLUMN delete_rule       FORMAT a10   HEADING 'Delete|Rule'
COLUMN status            FORMAT a9    HEADING 'Status'
COLUMN object_text       FORMAT a20   HEADING 'Object|Text'

(
  SELECT
      a.constraint_name
    , UPPER(:target_schema) schema
    , a.constraint_type
    , a.table_name
    , a.r_constraint_name
    , a.delete_rule
    , a.status
    , b.object_text
  FROM
      dba_constraints     a
    , schema_compare_temp b
  WHERE
        a.owner          = UPPER(:target_schema)
    AND a.table_name IN (
            select table_name
            from   user_tables
        )
    AND b.database(+)    = 2
    AND b.object_name(+) = a.constraint_name
  MINUS
  SELECT
      a.constraint_name
    , UPPER(:target_schema) schema
    , a.constraint_type
    , a.table_name
    , a.r_constraint_name
    , a.delete_rule
    , a.status
    , b.object_text
  FROM
      dba_constraints     a
    , schema_compare_temp  b
  WHERE
        a.owner          = UPPER(:source_schema)
    AND b.database(+)    = 1
    AND b.object_name(+) = a.constraint_name
)
UNION ALL
(
  SELECT
      a.constraint_name
    , UPPER(:source_schema) schema
    , a.constraint_type
    , a.table_name
    , a.r_constraint_name
    , a.delete_rule
    , a.status
    , b.object_text
  FROM
      dba_constraints     a
    , schema_compare_temp b
  WHERE
        a.owner          = UPPER(:source_schema)
    AND a.table_name IN (
            select table_name
            from   dba_tables
            where  owner = UPPER(:target_schema)
        )
    AND b.database(+)    = 1
    AND b.object_name(+) = a.constraint_name
  MINUS
  SELECT
      a.constraint_name
    , UPPER(:source_schema) schema
    , a.constraint_type
    , a.table_name
    , a.r_constraint_name
    , a.delete_rule
    , a.status
    , b.object_text
  FROM
      dba_constraints     a
    , schema_compare_temp b
  WHERE
        a.owner          = UPPER(:target_schema)
    AND b.database(+)    = 2
    AND b.object_name(+) = a.constraint_name
)
ORDER BY 4, 3, 2, 1;

SET HEADING  OFF
SET FEEDBACK OFF

PROMPT
SELECT '+----------------------------------------------------------------------+' || chr(10) ||
       '|                         SEQUENCE DIFFERENCES                         |' || chr(10) ||
       '+----------------------------------------------------------------------+'
FROM    dual;

SET HEADING  ON
SET FEEDBACK ON

PROMPT
PROMPT ========================================================
PROMPT Sequence discrepancies
PROMPT ========================================================

COLUMN sequence_name FORMAT a30  HEADING 'Sequence|Name'
COLUMN schema        FORMAT a30  HEADING 'Schema'
COLUMN min_value                 HEADING 'Min.|Value'
COLUMN max_value     FORMAT 9999999999999999999999999999 HEADING 'Max.|Value'
COLUMN increment_by              HEADING 'Increment|By'
COLUMN cycle_flag    FORMAT a5   HEADING 'Cycle|Flag'
COLUMN order_flag    FORMAT a5   HEADING 'Order|Flag'
COLUMN cache_size                HEADING 'Cache|Size'

(
  SELECT
      sequence_name
    , UPPER(:target_schema) schema
    , min_value
    , max_value
    , increment_by
    , cycle_flag
    , order_flag
    , cache_size
  FROM
      dba_sequences
  WHERE
      sequence_owner = UPPER(:target_schema)
  MINUS
  SELECT
      sequence_name
    , UPPER(:target_schema) schema
    , min_value
    , max_value
    , increment_by
    , cycle_flag
    , order_flag
    , cache_size
  FROM
      dba_sequences
  WHERE
      sequence_owner = UPPER(:source_schema)
)
UNION ALL
(
  SELECT
      sequence_name
    , UPPER(:source_schema) schema
    , min_value
    , max_value
    , increment_by
    , cycle_flag
    , order_flag
    , cache_size
  FROM
      dba_sequences
  WHERE
      sequence_owner = UPPER(:source_schema)
  MINUS
  SELECT
      sequence_name
    , UPPER(:source_schema) schema
    , min_value
    , max_value
    , increment_by
    , cycle_flag
    , order_flag
    , cache_size
  FROM
      dba_sequences
  WHERE
      sequence_owner = UPPER(:target_schema)
)
ORDER BY 1, 2;

SET HEADING  OFF
SET FEEDBACK OFF

PROMPT
SELECT '+----------------------------------------------------------------------+' || chr(10) ||
       '|                     PRIVATE SYNONYM DIFFERENCES                      |' || chr(10) ||
       '+----------------------------------------------------------------------+'
FROM    dual;

SET HEADING  ON
SET FEEDBACK ON

PROMPT
PROMPT ========================================================
PROMPT Private synonym discrepancies
PROMPT ========================================================

COLUMN synonym_name   FORMAT a30  HEADING 'Synonym|Name'
COLUMN schema         FORMAT a30  HEADING 'Schema'
COLUMN table_owner    FORMAT a20  HEADING 'Table|Owner'
COLUMN table_name     FORMAT a30  HEADING 'Table|Name'
COLUMN db_link        FORMAT a25  HEADING 'DB|Link Name'

(
  SELECT
      synonym_name
    , UPPER(:target_schema) schema
    , table_owner
    , table_name
    , db_link
  FROM
      dba_synonyms
  WHERE
      owner = UPPER(:target_schema)
  MINUS
  SELECT
      synonym_name
    , UPPER(:target_schema) schema
    , table_owner
    , table_name
    , db_link
  FROM     dba_synonyms
  WHERE
      owner = UPPER(:source_schema)
)
UNION ALL
(
  SELECT
      synonym_name
    , UPPER(:source_schema) schema
    , table_owner
    , table_name
    , db_link
  FROM
      dba_synonyms
  WHERE
      owner = UPPER(:source_schema)
  MINUS
  SELECT
      synonym_name
    , UPPER(:source_schema) schema
    , table_owner
    , table_name
    , db_link
  FROM
      dba_synonyms
  WHERE
      owner = UPPER(:target_schema)
)
ORDER BY 1, 2;

SET HEADING  OFF
SET FEEDBACK OFF

PROMPT
SELECT '+----------------------------------------------------------------------+' || chr(10) ||
       '|                          PL/SQL DIFFERENCES                          |' || chr(10) ||
       '+----------------------------------------------------------------------+'
FROM    dual;

SET HEADING  ON
SET FEEDBACK ON

PROMPT
PROMPT ========================================================
PROMPT Source code discrepancies for all packages, procedures, 
PROMPT and functions that exist in both schemas
PROMPT (CASE SENSITIVE COMPARISON)
PROMPT ========================================================

COLUMN name           FORMAT a30          HEADING 'Source|Name'
COLUMN type           FORMAT a20          HEADING 'Source|Type'
COLUMN discrepancies  FORMAT 999,999,999  HEADING 'Number|Discrepancies'

SELECT
    name
  , type
  , COUNT(*) discrepancies
FROM
    ( (  SELECT   name, type, line, text
         FROM     dba_source
         WHERE 
               owner = UPPER(:target_schema)
           AND (name, type) IN (
             SELECT object_name, object_type
             FROM   dba_objects
             WHERE  owner = UPPER(:source_schema)
         )
         MINUS
         SELECT   name, type, line, text
         FROM     dba_source
         WHERE owner = UPPER(:source_schema)
      )
      UNION ALL
      (  SELECT   name, type, line, text
         FROM     dba_source
         WHERE 
                owner = UPPER(:source_schema)
           AND (name, type) IN (
             SELECT object_name, object_type
             FROM   dba_objects
             WHERE owner = UPPER(:target_schema)
         )
         MINUS
         SELECT   name, type, line, text
         FROM     dba_source
         WHERE owner = UPPER(:target_schema)
      )
    )
GROUP BY name, type
ORDER BY name, type;

SET HEADING  OFF
SET FEEDBACK OFF

PROMPT
SELECT '+----------------------------------------------------------------------+' || chr(10) ||
       '|                         TRIGGER DIFFERENCES                          |' || chr(10) ||
       '+----------------------------------------------------------------------+'
FROM    dual;

SET HEADING  ON
SET FEEDBACK ON

PROMPT
PROMPT ========================================================
PROMPT Trigger discrepancies
PROMPT ========================================================

SET FEEDBACK OFF
SET TERMOUT  OFF

TRUNCATE TABLE schema_compare_temp
/

DECLARE

    CURSOR c1 IS
        SELECT trigger_name, trigger_body
        FROM   dba_triggers
        WHERE owner = UPPER(:source_schema);

    CURSOR c2 IS
        SELECT trigger_name, trigger_body
        FROM   dba_triggers
        WHERE owner = UPPER(:target_schema);

    v_trigger_name VARCHAR2(30);
    v_trigger_body VARCHAR2(32767);
    v_hash_value   NUMBER;
BEGIN

    OPEN c1;
    LOOP
        FETCH c1 INTO v_trigger_name, v_trigger_body;
        EXIT WHEN c1%NOTFOUND;
        v_trigger_body := REPLACE(v_trigger_body, ' ', NULL);
        v_trigger_body := REPLACE(v_trigger_body, CHR(9), NULL);
        v_trigger_body := REPLACE(v_trigger_body, CHR(10), NULL);
        v_trigger_body := REPLACE(v_trigger_body, CHR(13), NULL);
        v_trigger_body := UPPER(v_trigger_body);
        v_hash_value := dbms_utility.get_hash_value(v_trigger_body, 1, 65536);
        INSERT INTO schema_compare_temp (
            database, object_name, hash_value
        ) VALUES (
            1, v_trigger_name, v_hash_value
        );
    END LOOP;
    CLOSE c1;

    OPEN c2;
    LOOP
        FETCH c2 INTO v_trigger_name, v_trigger_body;
        EXIT WHEN c2%NOTFOUND;
        v_trigger_body := REPLACE(v_trigger_body, ' ', NULL);
        v_trigger_body := REPLACE(v_trigger_body, CHR(9), NULL);
        v_trigger_body := REPLACE(v_trigger_body, CHR(10), NULL);
        v_trigger_body := REPLACE(v_trigger_body, CHR(13), NULL);
        v_trigger_body := UPPER(v_trigger_body);
        v_hash_value := dbms_utility.get_hash_value(v_trigger_body, 1, 65536);
        INSERT INTO schema_compare_temp (
            database, object_name, hash_value
        ) VALUES (
            2, v_trigger_name, v_hash_value
        );
    END LOOP;
    CLOSE c2;

END;
/

SET FEEDBACK ON
SET TERMOUT  ON

COLUMN trigger_name       FORMAT a30    HEADING 'Trigger|Name'
COLUMN schema             FORMAT a30    HEADING 'Schema'
COLUMN trigger_type       FORMAT a16    HEADING 'Trigger|Type'
COLUMN triggering_event   FORMAT a20    HEADING 'Triggering|Event'
COLUMN table_name         FORMAT a30    HEADING 'Table|Name'
COLUMN referencing_names  FORMAT a20    HEADING 'Referencing|Names'
COLUMN when_clause        FORMAT a20    HEADING 'When|Clause'
COLUMN status             FORMAT a9     HEADING 'Status'
COLUMN hash_value                       HEADING 'Hash Value'

( SELECT
      a.trigger_name
    , UPPER(:source_schema) schema
    , a.trigger_type
    , SUBSTR(a.triggering_event, 1, 20)  triggering_event
    , a.table_name
    , SUBSTR(a.referencing_names, 1, 20) referencing_names
    , SUBSTR(a.when_clause, 1, 20)       when_clause
    , a.status
    , b.hash_value
  FROM
      dba_triggers        a
    , schema_compare_temp  b
  WHERE
        a.owner = UPPER(:source_schema)
    AND b.object_name(+) = a.trigger_name
    AND b.database(+)    = 1
    AND a.table_name IN (
            select table_name
            from   dba_tables
            where owner = UPPER(:target_schema)
        )
  MINUS
  SELECT
      a.trigger_name
    , UPPER(:source_schema) schema
    , a.trigger_type
    , SUBSTR(a.triggering_event, 1, 20)    triggering_event
    , a.table_name
    , SUBSTR(a.referencing_names, 1, 20)   referencing_names
    , SUBSTR(a.when_clause, 1, 20)         when_clause
    , a.status
    , b.hash_value
  FROM
      dba_triggers        a
    , schema_compare_temp b
  WHERE
        a.owner = UPPER(:target_schema)
    AND b.object_name(+) = a.trigger_name
    AND b.database(+)    = 2
)
UNION ALL
(
  SELECT
      a.trigger_name
    , UPPER(:target_schema) schema
    , a.trigger_type
    , SUBSTR(a.triggering_event, 1, 20)    triggering_event
    , a.table_name
    , SUBSTR(a.referencing_names, 1, 20)   referencing_names
    , SUBSTR(a.when_clause, 1, 20)         when_clause
    , a.status
    , b.hash_value
  FROM
      dba_triggers        a
    , schema_compare_temp b
  WHERE
        a.owner = UPPER(:target_schema)
    AND b.object_name(+) = a.trigger_name
    AND b.database(+)    = 2
    AND a.table_name IN (
            select table_name
            from   dba_tables
            where  owner = UPPER(:source_schema)
        )
  MINUS
  SELECT
      a.trigger_name
    , UPPER(:target_schema) schema
    , a.trigger_type
    , SUBSTR(a.triggering_event, 1, 20)    triggering_event
    , a.table_name
    , SUBSTR(a.referencing_names, 1, 20)   referencing_names
    , SUBSTR(a.when_clause, 1, 20)         when_clause
    , a.status
    , b.hash_value
  FROM
      dba_triggers        a
    , schema_compare_temp  b
  WHERE
        a.owner = UPPER(:source_schema)
    AND b.object_name(+)  = a.trigger_name
    AND b.database(+)     = 1
)
ORDER BY 1, 2, 5, 3;

SET HEADING  OFF
SET FEEDBACK OFF

PROMPT
SELECT '+----------------------------------------------------------------------+' || chr(10) ||
       '|                           VIEW DIFFERENCES                           |' || chr(10) ||
       '+----------------------------------------------------------------------+'
FROM    dual;

SET HEADING  ON
SET FEEDBACK ON

prompt
prompt ========================================================
prompt View discrepancies for views that exist in both
prompt schemas
prompt ========================================================

SET FEEDBACK OFF
SET TERMOUT OFF
SET LONG 32767

TRUNCATE TABLE schema_compare_temp
/

CREATE OR REPLACE FUNCTION getLongText (  p_tname IN VARCHAR2
                                        , p_cname IN VARCHAR2
                                        , p_vname IN VARCHAR2
                                        , p_sname IN VARCHAR2) RETURN VARCHAR2
  AS
    l_sql       VARCHAR2(4000);
    l_cursor    INTEGER DEFAULT dbms_sql.open_cursor;
    l_n         NUMBER;
    l_long_val  VARCHAR2(4000);
    l_long_len  NUMBER;
    l_buflen    NUMBER := 4000;
    l_curpos    NUMBER := 0;
  BEGIN
    l_sql := 'select ' || p_cname || ' from ' || p_tname || ' where UPPER(view_name) = UPPER(:view_name)';
    l_sql := l_sql || ' and owner = :owner';
    DBMS_SQL.PARSE(   l_cursor
                    , l_sql
                    , DBMS_SQL.NATIVE);
    DBMS_SQL.BIND_VARIABLE(l_cursor, ':view_name', p_vname);
    DBMS_SQL.BIND_VARIABLE(l_cursor, ':owner', p_sname);
    DBMS_SQL.DEFINE_COLUMN_LONG(l_cursor, 1);
    l_n := DBMS_SQL.EXECUTE(l_cursor);
  
    IF (DBMS_SQL.FETCH_ROWS(l_cursor) > 0)
      THEN
        DBMS_SQL.COLUMN_VALUE_LONG(   l_cursor
                                    , 1
                                    , l_buflen
                                    , l_curpos 
                                    , l_long_val
                                    , l_long_len);
    END IF;
    DBMS_SQL.CLOSE_CURSOR(l_cursor);
    RETURN l_long_val;
  END getLongText;
/

DECLARE

    CURSOR c1 IS
        SELECT view_name, getLongText('DBA_VIEWS', 'TEXT', view_name, UPPER(:source_schema))
        FROM   dba_views
        WHERE  owner = UPPER(:source_schema);

    CURSOR c2 IS
        SELECT view_name, getLongText('DBA_VIEWS', 'TEXT', view_name, UPPER(:target_schema))
        FROM   dba_views
        WHERE  owner = UPPER(:target_schema);

    v_view_name    VARCHAR2(30);
    v_text         VARCHAR2(32767);
    v_hash_value   NUMBER;

BEGIN

    OPEN c1;
    LOOP
        FETCH c1 INTO v_view_name, v_text;
        EXIT WHEN c1%NOTFOUND;
        v_hash_value := dbms_utility.get_hash_value(v_text, 1, 65536);
        INSERT INTO schema_compare_temp (
            database, object_name, object_text, hash_value
        ) VALUES (
            1, v_view_name, '[' || v_text || ']', v_hash_value
        );
    END LOOP;
    CLOSE c1;

    OPEN c2;
    LOOP
        FETCH c2 INTO v_view_name, v_text;
        EXIT WHEN c2%NOTFOUND;
        v_hash_value := dbms_utility.get_hash_value(v_text, 1, 65536);
        INSERT INTO schema_compare_temp (
            database, object_name, object_text, hash_value
        ) VALUES (
            2, v_view_name, '[' || v_text || ']', v_hash_value
        );
    END LOOP;
    CLOSE c2;
END;
/

SET TERMOU   ON
SET FEEDBACK ON

COLUMN view_name          FORMAT a30    HEADING 'View|Name'
COLUMN schema             FORMAT a30     HEADING 'Schema'
COLUMN hash_value                       HEADING 'Hash Value'

(
  SELECT
      a.view_name
    , UPPER(:source_schema) schema
    , b.hash_value
  FROM
      dba_views           a
    , schema_compare_temp b
  WHERE
        a.owner = UPPER(:source_schema)
    AND b.object_name(+) = a.view_name
    AND b.database(+)    = 1
    AND a.view_name IN (
            select view_name
            from   dba_views
            where  owner = UPPER(:target_schema)
        )
  MINUS
  SELECT
      a.view_name
    , UPPER(:source_schema) schema
    , b.hash_value
  FROM
      dba_views           a
    , schema_compare_temp b
  WHERE
        a.owner = UPPER(:target_schema)
    AND b.object_name(+)  = a.view_name
    AND b.database(+)     = 2
)
UNION ALL
(
  SELECT
      a.view_name
    , UPPER(:target_schema) schema
    , b.hash_value
  FROM
      dba_views           a
    , schema_compare_temp b
  WHERE
        a.owner = UPPER(:target_schema)
    AND b.object_name(+) = a.view_name
    AND b.database(+)    = 2
    AND a.view_name IN (
         select view_name
         from   dba_views
         where  owner = UPPER(:source_schema)
     )
  MINUS
  SELECT
      a.view_name
    , UPPER(:target_schema) schema
    , b.hash_value
  FROM
      dba_views           a
    , schema_compare_temp b
  WHERE
        a.owner = UPPER(:source_schema)
    AND b.object_name(+) = a.view_name
    AND b.database(+)    = 1
)
ORDER BY 1, 2;

SET HEADING  OFF
SET FEEDBACK OFF

PROMPT
SELECT '+----------------------------------------------------------------------+' || chr(10) ||
       '|                         JOB QUEUE DIFFERENCES                        |' || chr(10) ||
       '+----------------------------------------------------------------------+'
FROM    dual;

SET HEADING  ON
SET FEEDBACK ON

PROMPT
PROMPT ========================================================
PROMPT Job queue discrepancies
PROMPT ========================================================

COLUMN JOB_NAME        FORMAT a30   HEADING 'Job Name'
COLUMN REPEAT_INTERVAL FORMAT a30   HEADING 'Interval'
COLUMN JOB_TYPE        FORMAT a11   HEADING 'Job Type'

(
  SELECT
      JOB_NAME
    , JOB_TYPE
    , REPEAT_INTERVAL
    , UPPER(:target_schema) schema
  FROM
      dba_scheduler_jobs
  WHERE
      owner = UPPER(:target_schema)
  MINUS
  SELECT
      JOB_NAME
    , JOB_TYPE
    , REPEAT_INTERVAL
    , UPPER(:target_schema) schema
  FROM
      dba_scheduler_jobs
  WHERE
      owner = UPPER(:source_schema)
)
UNION ALL
(
  SELECT
      JOB_NAME
    , JOB_TYPE
    , REPEAT_INTERVAL
    , UPPER(:source_schema) schema
  FROM
      dba_scheduler_jobs
  WHERE
      owner = UPPER(:source_schema)
  MINUS
  SELECT
      JOB_NAME
    , JOB_TYPE
    , REPEAT_INTERVAL
    , UPPER(:source_schema) schema
  FROM
      dba_scheduler_jobs
  WHERE
      owner = UPPER(:target_schema)
)
ORDER BY 1, 2, 3;

SET HEADING  OFF
SET FEEDBACK OFF

PROMPT
SELECT '+----------------------------------------------------------------------+' || chr(10) ||
       '|                      DATABASE LINK DIFFERENCES                       |' || chr(10) ||
       '+----------------------------------------------------------------------+'
FROM    dual;

SET HEADING  ON
SET FEEDBACK ON

PROMPT
PROMPT ========================================================
PROMPT Database link discrepancies
PROMPT ========================================================

COLUMN db_link        FORMAT a30  HEADING 'DB Link Name'
COLUMN schema         FORMAT a30  HEADING 'Schema'
COLUMN username       FORMAT a20  HEADING 'User Name'
COLUMN host           FORMAT a20  HEADING 'Host'

(
  SELECT
      db_link
    , UPPER(:target_schema) schema
    , username
    , host
  FROM
      dba_db_links
  WHERE
      owner = UPPER(:target_schema)
  MINUS
  SELECT
      db_link
    , UPPER(:target_schema) schema
    , username, host
  FROM
      dba_db_links
  WHERE
      owner = UPPER(:source_schema)
)
UNION ALL
(
  SELECT
      db_link
    , UPPER(:source_schema) schema
    , username, host
  FROM
      dba_db_links
  WHERE
        owner = UPPER(:source_schema)
    AND db_link NOT LIKE 'REMOTE_SCHEMA_LINK.%'
  MINUS
  SELECT
      db_link
    , UPPER(:source_schema) schema
    , username
    , host
  FROM
      dba_db_links
  WHERE
      owner = UPPER(:target_schema)
)
ORDER BY 1, 2;

PROMPT
PROMPT =============
PROMPT END OF REPORT
PROMPT =============
PROMPT

DROP TABLE schema_compare_temp PURGE;
DROP FUNCTION getLongText;]]></sql>
			<binds>
				<bind id="source_schema">
					<prompt><![CDATA[Source schema]]></prompt>
					<tooltip><![CDATA[Enter the source's schema name for comparison]]></tooltip>
					<value><![CDATA[CLASS]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
				<bind id="target_schema">
					<prompt><![CDATA[Target schema]]></prompt>
					<tooltip><![CDATA[Enter the target's schema name for comparison]]></tooltip>
					<value><![CDATA[ANDERSONBESTTETI]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
			</binds>
		</query>
			<pdf version="VERSION_1_7" compression="CONTENT">
				<docproperty title="Schema Diff" author="" subject="Show the differece among related schema objects" keywords="Tables, Columns, Constraints, Indexes, Views, Sequences, Procedures, Functions, Packages, Database links" />
				<cell toppadding="2" bottompadding="2" leftpadding="2" rightpadding="2" horizontalalign="LEFT" verticalalign="TOP" wrap="true" />
				<column>
					<heading font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="FIRST_PAGE" />
					<footing font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="NONE" />
					<blob blob="NONE" zip="false" />
				</column>
				<table font="null" size="10" style="NORMAL" color="-16777216" userowshading="false" oddrowshading="-1" evenrowshading="-1" showborders="true" spacingbefore="12" spacingafter="12" horizontalalign="LEFT" />
				<header enable="false" generatedate="false">
					<data>
					
					
					
					
					
					null																														</data>
				</header>
				<footer enable="false" generatedate="false">
					<data value="null" />
				</footer>
				<pagesetup papersize="LETTER" orientation="1" measurement="in" margintop="1.0" marginbottom="1.0" marginleft="1.0" marginright="1.0" />
			</pdf>
	</display>
	<display id="fde0c87c-0165-1000-8001-0ac80a613e13" type="" style="Table" enable="true">
		<name><![CDATA[Foreign Keys without index]]></name>
		<description><![CDATA[Show foreign key constraints withou index to support them.]]></description>
		<tooltip><![CDATA[Show foreign key constraints withou index to support them.]]></tooltip>
		<drillclass><![CDATA[]]></drillclass>
		<CustomValues>
			<TYPE><![CDATA[horizontal]]></TYPE>
		</CustomValues>
		<query>
			<sql><![CDATA[SELECT
   dbcc.table_name,
   dbcc.constraint_name,
   dbcc.column_name
FROM
   dba_cons_columns dbcc,
   ( SELECT
        b.owner,
        b.table_name,
        a.position,
        a.column_name
    FROM
        dba_cons_columns a,
        dba_constraints  b
    WHERE
        b.owner           = UPPER(:p_schema)
    AND a.owner           = b.owner
    AND a.table_name      = b.table_name
    AND a.constraint_name = b.constraint_name
    AND b.constraint_type = 'R'
    MINUS
    SELECT
        c.index_owner     as owner,
        c.table_name,
        c.column_position as position,
        c.column_name
    FROM
        dba_ind_columns c
    WHERE
        c.index_owner = UPPER(:p_schema)
   ) d
WHERE
     dbcc.owner       = d.owner
AND  dbcc.table_name  = d.table_name
AND  dbcc.column_name = d.column_name
AND  dbcc.position    = d.position
ORDER BY 1, 2]]></sql>
			<binds>
				<bind id="p_schema">
					<prompt><![CDATA[Enter the schema name]]></prompt>
					<tooltip><![CDATA[Enter the schema to scan from FKs without index.]]></tooltip>
					<value><![CDATA[ANDERSONBESTTETI]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
			</binds>
		</query>
			<pdf version="VERSION_1_7" compression="CONTENT">
				<docproperty title="null" author="null" subject="null" keywords="null" />
				<cell toppadding="2" bottompadding="2" leftpadding="2" rightpadding="2" horizontalalign="LEFT" verticalalign="TOP" wrap="true" />
				<column>
					<heading font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="FIRST_PAGE" />
					<footing font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="NONE" />
					<blob blob="NONE" zip="false" />
				</column>
				<table font="null" size="10" style="NORMAL" color="-16777216" userowshading="false" oddrowshading="-1" evenrowshading="-1" showborders="true" spacingbefore="12" spacingafter="12" horizontalalign="LEFT" />
				<header enable="false" generatedate="false">
					<data>
					
					null										</data>
				</header>
				<footer enable="false" generatedate="false">
					<data value="null" />
				</footer>
				<pagesetup papersize="LETTER" orientation="1" measurement="in" margintop="1.0" marginbottom="1.0" marginleft="1.0" marginright="1.0" />
			</pdf>
	</display>
</folder>
</displays>